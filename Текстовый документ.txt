package com.example.scorochenie.data

data class TestResult(
    val techniqueName: String,
    val durationPerWord: Long,
    val score: Int,
    val totalQuestions: Int,
    val timestamp: Long
)package com.example.scorochenie.domain

import android.animation.ValueAnimator
import android.graphics.Color
import android.text.Spannable
import android.text.SpannableString
import android.text.style.BackgroundColorSpan
import android.text.style.StyleSpan
import android.util.Log
import android.view.View
import android.widget.ScrollView
import android.widget.TextView
import androidx.core.animation.addListener
import kotlin.math.min

class BlockReadingTechnique : ReadingTechnique("Чтение \"блоками\"") {
    private var currentBlockIndex = 0
    private var selectedTextIndex = 0
    private var fullText: String = ""
    private var animator: ValueAnimator? = null
    private var currentPartText: String = ""
    private var lineCount: Int = 0
    private var lines: List<IntRange> = emptyList()
    private var scrollView: ScrollView? = null
    private var lastScrollY: Int = 0

    override val description: SpannableString
        get() {
            val text = "Чтение \"блоками\" — это техника скорочтения, при которой текст воспринимается не по отдельным словам, а целыми смысловыми фрагментами. Такой подход помогает быстрее обрабатывать информацию и лучше удерживать общий контекст.\n" +
                    "Сосредоточьтесь на восприятии сразу нескольких строк как единого блока — это развивает навык охватывать больше текста за раз и ускоряет чтение без потери понимания."
            val spannable = SpannableString(text)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), 0, name.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("целыми смысловыми фрагментами"), text.indexOf("целыми смысловыми фрагментами") + "целыми смысловыми фрагментами".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("сразу нескольких строк"), text.indexOf("сразу нескольких строк") + "сразу нескольких строк".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        }

    override fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,
        onAnimationEnd: () -> Unit
    ) {
        try {
            this.selectedTextIndex = selectedTextIndex
            fullText = TextResources.otherTexts["Чтение блоками"]?.getOrNull(selectedTextIndex)?.text?.replace("\n", " ") ?: ""
            if (fullText.isEmpty()) {
                Log.e("BlockReading", "No text available for selectedTextIndex=$selectedTextIndex")
                textView.text = "Текст недоступен"
                onAnimationEnd()
                return
            }

            currentBlockIndex = 0
            lastScrollY = 0

            // Проверяем durationPerWord
            if (durationPerWord <= 0) {
                Log.e("BlockReading", "Invalid durationPerWord: $durationPerWord")
                textView.text = "Ошибка: некорректная скорость чтения"
                onAnimationEnd()
                return
            }

            // Преобразуем WPM в миллисекунды на слово
            val wordDurationMs = (60_000 / durationPerWord).coerceAtLeast(50L)
            Log.d("BlockReading", "Starting animation with durationPerWord=$durationPerWord WPM, wordDurationMs=$wordDurationMs ms, selectedTextIndex=$selectedTextIndex, textLength=${fullText.length}")

            scrollView = textView.parent as? ScrollView
            Log.d("BlockReading", "ScrollView initialized: $scrollView, parent=${textView.parent}, parentClass=${textView.parent?.javaClass?.simpleName}")
            if (scrollView == null) {
                Log.w("BlockReading", "TextView is not inside a ScrollView, scrolling will be disabled")
            } else {
                Log.d("BlockReading", "ScrollView height: ${scrollView?.height}, width: ${scrollView?.width}")
            }

            textView.gravity = android.view.Gravity.TOP
            textView.isSingleLine = false
            textView.maxLines = Int.MAX_VALUE
            textView.post {
                showNextTextPart(textView, guideView, wordDurationMs, onAnimationEnd)
            }
        } catch (e: Exception) {
            Log.e("BlockReading", "Error in startAnimation: ${e.message}", e)
            textView.text = "Ошибка анимации"
            onAnimationEnd()
        }
    }

    private fun showNextTextPart(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        currentPartText = fullText
        textView.text = currentPartText

        textView.post {
            val layout = textView.layout
            if (layout == null) {
                Log.e("BlockReading", "TextView layout is null in showNextTextPart")
                textView.text = "Ошибка отображения текста"
                onAnimationEnd()
                return@post
            }
            lineCount = layout.lineCount
            lines = (0 until lineCount).map { line ->
                layout.getLineStart(line)..layout.getLineEnd(line)
            }
            currentBlockIndex = 0

            Log.d("BlockReading", "Showing full text: '${currentPartText.take(50)}...', lineCount=$lineCount")
            Log.d("BlockReading", "Lines: ${lines.map { currentPartText.substring(it.first, it.last) }.joinToString(" | ")}")

            animateNextBlock(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun animateNextBlock(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        if (currentBlockIndex * 2 >= lineCount) {
            guideView.visibility = View.INVISIBLE
            Log.d("BlockReading", "Text ended, stopping animation")
            animator?.cancel()
            textView.text = currentPartText
            onAnimationEnd()
            return
        }

        val (wordCountInBlock, firstLineWordCount, secondLineWordCount) = highlightBlock(textView)
        startBlockAnimation(textView, guideView, wordDurationMs, wordCountInBlock, firstLineWordCount, secondLineWordCount, onAnimationEnd)
    }

    private fun highlightBlock(textView: TextView): Triple<Int, Int, Int> {
        val spannable = SpannableString(currentPartText)
        val existingSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
        for (span in existingSpans) {
            spannable.removeSpan(span)
        }

        val firstLineIndex = currentBlockIndex * 2
        val secondLineIndex = min(firstLineIndex + 1, lineCount - 1)
        val startIndex = lines[firstLineIndex].first
        val endIndex = lines[secondLineIndex].last

        // Подсчитываем количество слов в блоке и в каждой строке
        val blockText = currentPartText.substring(startIndex, endIndex)
        val wordCountInBlock = blockText.split("\\s+".toRegex()).filter { it.isNotEmpty() }.size

        val firstLineText = currentPartText.substring(lines[firstLineIndex].first, lines[firstLineIndex].last)
        val firstLineWordCount = firstLineText.split("\\s+".toRegex()).filter { it.isNotEmpty() }.size

        val secondLineText = if (secondLineIndex > firstLineIndex) {
            currentPartText.substring(lines[secondLineIndex].first, lines[secondLineIndex].last)
        } else {
            ""
        }
        val secondLineWordCount = secondLineText.split("\\s+".toRegex()).filter { it.isNotEmpty() }.size

        if (startIndex < spannable.length && endIndex <= spannable.length) {
            spannable.setSpan(
                BackgroundColorSpan(Color.YELLOW),
                startIndex,
                endIndex,
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            Log.d("BlockReading", "Highlighting block: lines $firstLineIndex-$secondLineIndex, start=$startIndex, end=$endIndex, text='$blockText', wordCount=$wordCountInBlock, firstLineWords=$firstLineWordCount, secondLineWords=$secondLineWordCount")
        } else {
            Log.e("BlockReading", "Invalid block indices: start=$startIndex, end=$endIndex, spannable.length=${spannable.length}")
        }

        textView.text = spannable
        return Triple(wordCountInBlock, firstLineWordCount, secondLineWordCount)
    }

    private fun startBlockAnimation(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        wordCountInBlock: Int,
        firstLineWordCount: Int,
        secondLineWordCount: Int,
        onAnimationEnd: () -> Unit
    ) {
        guideView.visibility = View.INVISIBLE
        animator?.cancel()

        val layout = textView.layout
        if (layout == null) {
            Log.e("BlockReading", "TextView layout is null")
            textView.postDelayed({ animateNextBlock(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val firstLineIndex = currentBlockIndex * 2
        val secondLineIndex = min(firstLineIndex + 1, lineCount - 1)
        val startIndex = lines[firstLineIndex].first
        val endIndex = lines[secondLineIndex].last

        // Позиции для первой строки
        val firstLineStartX = layout.getLineLeft(firstLineIndex)
        val firstLineEndX = layout.getLineRight(firstLineIndex)
        val firstLineTop = layout.getLineTop(firstLineIndex).toFloat()
        val firstLineBottom = layout.getLineBottom(firstLineIndex).toFloat()
        val firstLineY = (firstLineTop + firstLineBottom) / 2

        // Позиции для второй строки
        val secondLineStartX = layout.getLineLeft(secondLineIndex)
        val secondLineEndX = layout.getLineRight(secondLineIndex)
        val secondLineTop = layout.getLineTop(secondLineIndex).toFloat()
        val secondLineBottom = layout.getLineBottom(secondLineIndex).toFloat()
        val secondLineY = (secondLineTop + secondLineBottom) / 2

        // Рассчитываем длительность анимации блока
        val blockDurationMs = (wordCountInBlock * wordDurationMs).coerceAtLeast(50L)

        // Распределяем длительность между строками пропорционально количеству слов
        val totalWords = firstLineWordCount + secondLineWordCount
        val firstLineDuration = if (totalWords > 0) {
            (blockDurationMs * firstLineWordCount / totalWords.toFloat()).toLong().coerceAtLeast(50L)
        } else {
            blockDurationMs / 2
        }
        val secondLineDuration = (blockDurationMs - firstLineDuration).coerceAtLeast(50L)

        // Прокрутка ScrollView
        scrollView?.let { sv ->
            sv.post {
                val scrollViewHeight = sv.height
                val currentScrollY = sv.scrollY
                val lineTopPosition = layout.getLineTop(firstLineIndex)
                val lineBottomPosition = layout.getLineBottom(secondLineIndex)

                // Определяем видимую область (верхняя треть экрана)
                val visibleTop = currentScrollY
                val visibleBottom = currentScrollY + scrollViewHeight * 2 / 3

                // Прокручиваем, если блок не полностью виден
                if (lineTopPosition < visibleTop || lineBottomPosition > visibleBottom) {
                    // Цель: поставить верх блока в верхнюю треть экрана
                    val targetScrollY = (lineTopPosition - scrollViewHeight / 3).coerceAtLeast(0).toInt()
                    if (targetScrollY != lastScrollY) {
                        Log.d("BlockReading", "Attempting scroll for block $currentBlockIndex, lines $firstLineIndex-$secondLineIndex")
                        Log.d("BlockReading", "Scroll parameters: block=$currentBlockIndex, lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, scrollViewHeight=$scrollViewHeight, currentScrollY=$currentScrollY, targetScrollY=$targetScrollY")
                        // Плавная прокрутка
                        ValueAnimator.ofInt(currentScrollY, targetScrollY).apply {
                            duration = blockDurationMs / 2 // Прокрутка быстрее анимации блока
                            addUpdateListener { animation ->
                                val value = animation.animatedValue as Int
                                sv.scrollTo(0, value)
                            }
                            addListener(
                                onEnd = {
                                    lastScrollY = targetScrollY
                                    Log.d("BlockReading", "Scrolled to block $currentBlockIndex, targetScrollY=$targetScrollY, currentScrollY=${sv.scrollY}")
                                }
                            )
                            start()
                        }
                    } else {
                        Log.d("BlockReading", "No scroll needed, already at target: block=$currentBlockIndex, targetScrollY=$targetScrollY")
                    }
                } else {
                    Log.d("BlockReading", "No scroll needed, block $currentBlockIndex is visible, lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, visibleTop=$visibleTop, visibleBottom=$visibleBottom")
                }

                sv.postDelayed({
                    Log.d("BlockReading", "After scroll check, currentScrollY=${sv.scrollY}, textViewHeight=${textView.height}, scrollViewHeight=$scrollViewHeight")
                }, 100)
            }
        }

        Log.d("BlockReading", "Animating block: $currentBlockIndex, firstLine: startX=$firstLineStartX, endX=$firstLineEndX, y=$firstLineY, duration=$firstLineDuration ms; secondLine: startX=$secondLineStartX, endX=$secondLineEndX, y=$secondLineY, duration=$secondLineDuration ms; wordCount=$wordCountInBlock, totalDuration=$blockDurationMs ms")

        // Анимация первой строки
        animator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = firstLineDuration
            addUpdateListener { animation ->
                val fraction = animation.animatedValue as Float
                val currentX = firstLineStartX + (firstLineEndX - firstLineStartX) * fraction
                guideView.translationX = currentX - (guideView.width / 2) + textView.left
                guideView.translationY = firstLineY + textView.top.toFloat() - (scrollView?.scrollY?.toFloat() ?: 0f)
            }
            addListener(
                onEnd = {
                    // Анимация второй строки
                    animator = ValueAnimator.ofFloat(0f, 1f).apply {
                        duration = secondLineDuration
                        addUpdateListener { animation ->
                            val fraction = animation.animatedValue as Float
                            val currentX = secondLineStartX + (secondLineEndX - secondLineStartX) * fraction
                            guideView.translationX = currentX - (guideView.width / 2) + textView.left
                            guideView.translationY = secondLineY + textView.top.toFloat() - (scrollView?.scrollY?.toFloat() ?: 0f)
                        }
                        addListener(
                            onEnd = {
                                currentBlockIndex++
                                Log.d("BlockReading", "Block animation ended, currentBlockIndex=$currentBlockIndex")
                                animateNextBlock(textView, guideView, wordDurationMs, onAnimationEnd)
                            }
                        )
                        start()
                    }
                }
            )
            start()
        }
    }
    override fun cancelAnimation() {
        animator?.cancel()
        Log.d("BlockReading", "Animation cancelled")
    }
}package com.example.scorochenie.domain

import android.animation.ValueAnimator
import android.graphics.Color
import android.text.Spannable
import android.text.SpannableString
import android.text.style.BackgroundColorSpan
import android.text.style.StyleSpan
import android.util.Log
import android.view.View
import android.view.animation.LinearInterpolator
import android.widget.TextView
import androidx.core.animation.addListener
import com.example.scorochenie.ui.DiagonalLineView
import com.example.scorochenie.R
import kotlin.math.abs

class DiagonalReadingTechnique : ReadingTechnique("Чтение по диагонали") {
    private var currentPosition = 0
    private var breakWordIndex = 0
    private var selectedTextIndex = 0
    private var fullText: String = ""
    private var animator: ValueAnimator? = null

    override val description: SpannableString
        get() {
            val text = "Чтение по диагонали — это способ быстрого ознакомления с текстом, при котором взгляд скользит сверху вниз по диагонали, захватывая общую структуру и главные элементы.\n" +
                    "Вместо того чтобы читать каждое слово, вы охватываете страницу бегло, выхватывая смысловые опоры — такие как начальные и конечные слова абзацев, цифры или повторы.\n" +
                    "Этот метод позволяет быстро получить общее представление о содержании и решить, стоит ли читать подробнее."
            val spannable = SpannableString(text)

            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), 0, name.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("сверху вниз по диагонали"), text.indexOf("сверху вниз по диагонали") + "сверху вниз по диагонали".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("смысловые опоры"), text.indexOf("смысловые опоры") + "смысловые опоры".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("начальные и конечные"), text.indexOf("начальные и конечные") + "начальные и конечные".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        }

    override fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,
        onAnimationEnd: () -> Unit
    ) {
        this.selectedTextIndex = selectedTextIndex
        fullText = TextResources.diagonalTexts.getOrNull(selectedTextIndex)?.text?.replace("\n", " ") ?: ""
        currentPosition = 0
        breakWordIndex = 0

        val wordDurationMs = (60_000 / durationPerWord).coerceAtLeast(50L)
        Log.d("DiagonalReading", "Starting animation with durationPerWord=$durationPerWord WPM, wordDurationMs=$wordDurationMs ms")

        guideView.visibility = View.INVISIBLE
        Log.d("DiagonalReading", "startAnimation: guideView visibility=${guideView.visibility} (0=INVISIBLE, 8=VISIBLE)")

        textView.gravity = android.view.Gravity.TOP
        textView.isSingleLine = false
        textView.maxLines = Int.MAX_VALUE

        textView.post {
            Log.d("DiagonalReading", "TextView size after post: ${textView.width}x${textView.height}")
            val parent = textView.parent as View
            Log.d("DiagonalReading", "FrameLayout size after text set: ${parent.width}x${parent.height}")
            showNextTextPart(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun showNextTextPart(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        if (currentPosition >= fullText.length) {
            guideView.visibility = View.INVISIBLE
            Log.d("DiagonalReading", "Text ended, stopping animation, guideView visibility=${guideView.visibility}")
            animator?.cancel()
            clearHighlight(textView)
            onAnimationEnd()
            return
        }

        val currentBreakWords = TextResources.diagonalTexts.getOrNull(selectedTextIndex)?.breakWords ?: emptyList()
        val breakWord = if (breakWordIndex < currentBreakWords.size) currentBreakWords[breakWordIndex] else ""
        val breakPosition = if (breakWord.isNotEmpty()) {
            val index = fullText.indexOf(breakWord, currentPosition)
            if (index == -1) fullText.length else index + breakWord.length
        } else {
            fullText.length
        }

        val partText = fullText.substring(currentPosition, breakPosition).trim()
        Log.d("DiagonalReading", "Showing part: startPosition=$currentPosition, endPosition=$breakPosition, breakWord='$breakWord', text='$partText'")

        textView.text = partText
        textView.visibility = View.VISIBLE

        textView.post {
            Log.d("DiagonalReading", "TextView size after text set: ${textView.width}x${textView.height}")
            val parent = textView.parent as View
            Log.d("DiagonalReading", "FrameLayout size after text set: ${parent.width}x${parent.height}")
            val diagonalLineView = parent.findViewById<DiagonalLineView>(R.id.diagonal_line_view)
            if (diagonalLineView != null) {
                diagonalLineView.requestLayout()
                Log.d("DiagonalReading", "DiagonalLineView found, visibility=${diagonalLineView.visibility}")
                startDiagonalAnimation(textView, guideView, breakPosition, partText, wordDurationMs, onAnimationEnd)
            } else {
                Log.e("DiagonalReading", "DiagonalLineView not found, skipping animation")
                onAnimationEnd()
            }
        }
    }

    private fun startDiagonalAnimation(
        textView: TextView,
        guideView: View,
        newPosition: Int,
        partText: String,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        animator?.cancel()

        val wordCount = partText.split("\\s+".toRegex()).filter { it.isNotEmpty() }.size
        val totalDuration = wordCount * wordDurationMs

        Log.d("DiagonalReading", "Animating part with wordCount=$wordCount, wordDurationMs=$wordDurationMs, totalDuration=$totalDuration ms")

        val layout = textView.layout
        if (layout == null) {
            Log.e("DiagonalReading", "TextView layout is null, retrying")
            textView.requestLayout()
            textView.postDelayed({ startDiagonalAnimation(textView, guideView, newPosition, partText, wordDurationMs, onAnimationEnd) }, 50)
            return
        }

        val width = textView.width.toFloat()
        val visibleHeight = textView.height.toFloat()
        val totalLines = layout.lineCount
        val lastLineTop = if (totalLines > 1) layout.getLineTop(totalLines - 1) else visibleHeight
        val heightExcludingLastLine = if (totalLines > 1) lastLineTop.toFloat() else visibleHeight

        guideView.visibility = View.INVISIBLE
        guideView.translationX = 0f
        guideView.translationY = 0f
        Log.d("DiagonalReading", "Initial guideView position: x=${guideView.translationX}, y=${guideView.translationY}, visibility=${guideView.visibility}")

        val initialLine = highlightWordAtPosition(textView, 0f, 0f, -1)
        Log.d("DiagonalReading", "Initial highlight called, currentLine=$initialLine")

        var lastTime = System.currentTimeMillis()
        var lastX = 0f
        var lastY = 0f

        animator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = totalDuration
            interpolator = LinearInterpolator() // Гарантируем линейное изменение
            var lastLine = initialLine

            addUpdateListener { animation ->
                val fraction = animation.animatedValue as Float
                val y = fraction * heightExcludingLastLine
                val x = fraction * width

                guideView.translationX = x - (guideView.width / 2)
                guideView.translationY = y

                val currentTime = System.currentTimeMillis()
                val deltaTime = (currentTime - lastTime) / 1000f
                if (deltaTime > 0) {
                    val speedX = (x - lastX) / deltaTime
                    val speedY = (y - lastY) / deltaTime
                    Log.d("DiagonalReading", "guideView position: x=$x, y=$y, fraction=$fraction, visibility=${guideView.visibility}, speedX=$speedX px/s, speedY=$speedY px/s")
                }
                lastTime = currentTime
                lastX = x
                lastY = y

                val currentLine = highlightWordAtPosition(textView, x, y, lastLine)
                if (currentLine != -1) lastLine = currentLine
            }
            addListener(
                onEnd = {
                    clearHighlight(textView)
                    guideView.visibility = View.INVISIBLE
                    Log.d("DiagonalReading", "Animation ended, guideView visibility=${guideView.visibility}")
                    currentPosition = newPosition
                    breakWordIndex++
                    Log.d("DiagonalReading", "Animation ended, new currentPosition=$currentPosition, breakWordIndex=$breakWordIndex")
                    showNextTextPart(textView, guideView, wordDurationMs, onAnimationEnd)
                }
            )
            start()
        }
    }

    private fun highlightWordAtPosition(textView: TextView, x: Float, y: Float, lastLine: Int): Int {
        val layout = textView.layout ?: return -1
        val visibleHeight = textView.height.toFloat()

        val adjustedY = y.coerceIn(0f, visibleHeight)
        val currentLine = layout.getLineForVertical(adjustedY.toInt())

        val totalLines = layout.lineCount
        if (currentLine == totalLines - 1 || currentLine <= lastLine) {
            return currentLine
        }

        val diagonalSlope = visibleHeight / textView.width.toFloat()
        val expectedX = adjustedY / diagonalSlope

        var closestOffset = -1
        var minDistance = Float.MAX_VALUE

        for (offset in layout.getLineStart(currentLine) until layout.getLineEnd(currentLine)) {
            if (textView.text[offset].isWhitespace()) continue

            val charLeft = layout.getPrimaryHorizontal(offset)
            val charRight = if (offset + 1 < textView.text.length) layout.getPrimaryHorizontal(offset + 1) else charLeft
            var charX = (charLeft + charRight) / 2

            val distance = abs(charX - expectedX)
            if (distance < minDistance) {
                minDistance = distance
                closestOffset = offset
            }
        }

        if (closestOffset != -1) {
            val text = textView.text.toString()
            var start = closestOffset
            var end = closestOffset

            while (start > 0 && !text[start - 1].isWhitespace()) start--
            while (end < text.length && !text[end].isWhitespace()) end++

            val spannable = SpannableString(text)
            val existingSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
            for (span in existingSpans) {
                spannable.removeSpan(span)
            }
            spannable.setSpan(
                BackgroundColorSpan(Color.YELLOW),
                start,
                end,
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            textView.text = spannable
            Log.d("DiagonalReading", "Highlighted word: start=$start, end=$end, text='${text.substring(start, end)}'")
        }

        return currentLine
    }

    private fun clearHighlight(textView: TextView) {
        val text = textView.text.toString()
        val spannable = SpannableString(text)
        val existingSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
        for (span in existingSpans) {
            spannable.removeSpan(span)
        }
        textView.text = spannable
        Log.d("DiagonalReading", "Cleared highlight from text")
    }
    override fun cancelAnimation() {
        animator?.cancel()
        Log.d("DiagonalReading", "Animation cancelled")
    }
}package com.example.scorochenie.domain

import android.animation.ValueAnimator
import android.graphics.Color
import android.text.Spannable
import android.text.SpannableString
import android.text.style.BackgroundColorSpan
import android.text.style.StyleSpan
import android.util.Log
import android.view.View
import android.widget.ScrollView
import android.widget.TextView
import androidx.core.animation.addListener
import androidx.core.content.ContextCompat
import android.graphics.Typeface
import com.example.scorochenie.R

class KeywordSearchTechnique : ReadingTechnique("Поиск ключевых слов") {
    private var currentWordIndex = 0
    private var selectedTextIndex = 0
    private var fullText: String = ""
    private var animator: ValueAnimator? = null
    private var currentPartWords: List<String> = emptyList()
    private var currentPartText: String = ""
    private var scrollView: ScrollView? = null
    private var lastScrollY: Int = 0

    override val description: SpannableString
        get() {
            val text = "Поиск ключевых слов — это техника скорочтения, при которой внимание сосредотачивается на наиболее важных словах и фразах, несущих основную смысловую нагрузку.\n" +
                    "Ключевые элементы текста уже выделены — фокусируйтесь именно на них, чтобы быстрее уловить суть.\n" +
                    "Пропуская второстепенные детали, вы быстрее ориентируетесь в материале и эффективнее воспринимаете основное содержание."
            val spannable = SpannableString(text)
            spannable.setSpan(StyleSpan(Typeface.BOLD), 0, name.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(Typeface.BOLD), text.indexOf("основную смысловую нагрузку"), text.indexOf("основную смысловую нагрузку") + "основную смысловую нагрузку".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(Typeface.BOLD), text.indexOf("именно на них"), text.indexOf("именно на них") + "именно на них".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(Typeface.BOLD), text.indexOf("выделены"), text.indexOf("выделены") + "выделены".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        }

    override fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,
        onAnimationEnd: () -> Unit
    ) {
        this.selectedTextIndex = selectedTextIndex
        fullText = TextResources.keywordTexts.getOrNull(selectedTextIndex)?.text?.replace("\n", " ") ?: ""
        currentWordIndex = 0
        lastScrollY = 0

        // Преобразуем WPM в миллисекунды на слово
        val wordDurationMs = (60_000 / durationPerWord).coerceAtLeast(50L)
        Log.d("KeywordSearch", "Starting animation with durationPerWord=$durationPerWord WPM, wordDurationMs=$wordDurationMs ms, selectedTextIndex=$selectedTextIndex, textLength=${fullText.length}")

        scrollView = textView.parent as? ScrollView
        Log.d("KeywordSearch", "ScrollView initialized: $scrollView, parent=${textView.parent}, parentClass=${textView.parent?.javaClass?.simpleName}")
        if (scrollView == null) {
            Log.e("KeywordSearch", "TextView is not inside a ScrollView, scrolling will not work")
        } else {
            Log.d("KeywordSearch", "ScrollView height: ${scrollView?.height}, width: ${scrollView?.width}")
        }

        textView.gravity = android.view.Gravity.TOP
        textView.isSingleLine = false
        textView.maxLines = Int.MAX_VALUE
        textView.post {
            showNextTextPart(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun showNextTextPart(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        currentPartText = fullText
        currentPartWords = currentPartText.split("\\s+".toRegex()).filter { it.isNotEmpty() }
        currentWordIndex = 0

        Log.d("KeywordSearch", "Showing full text: '${currentPartText.take(50)}...', wordCount=${currentPartWords.size}")

        textView.text = currentPartText
        animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
    }

    private fun animateNextWord(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        if (currentWordIndex >= currentPartWords.size) {
            guideView.visibility = View.INVISIBLE
            Log.d("KeywordSearch", "Text ended, stopping animation")
            animator?.cancel()
            textView.text = currentPartText
            onAnimationEnd()
            return
        }

        highlightWord(textView)
        startWordAnimation(textView, guideView, wordDurationMs, onAnimationEnd)
    }

    private fun highlightWord(textView: TextView) {
        val spannable = SpannableString(currentPartText)

        // Удаляем все существующие BackgroundColorSpan, StyleSpan и ForegroundColorSpan
        val existingBackgroundSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
        for (span in existingBackgroundSpans) {
            spannable.removeSpan(span)
        }
        val existingStyleSpans = spannable.getSpans(0, spannable.length, StyleSpan::class.java)
        for (span in existingStyleSpans) {
            spannable.removeSpan(span)
        }
        val existingForegroundSpans = spannable.getSpans(0, spannable.length, android.text.style.ForegroundColorSpan::class.java)
        for (span in existingForegroundSpans) {
            spannable.removeSpan(span)
        }

        // Выделяем ключевые слова жирным шрифтом и цветом из ресурсов
        val keyWords = TextResources.keywordTexts.getOrNull(selectedTextIndex)?.keyWords ?: emptyList()
        val foundKeyWords = mutableListOf<String>()
        keyWords.forEach { keyWord ->
            var startIndex = currentPartText.indexOf(keyWord, ignoreCase = false)
            while (startIndex != -1) {
                val endIndex = startIndex + keyWord.length
                spannable.setSpan(
                    StyleSpan(Typeface.BOLD),
                    startIndex,
                    endIndex,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                spannable.setSpan(
                    android.text.style.ForegroundColorSpan(ContextCompat.getColor(textView.context,
                        R.color.keyword_color
                    )),
                    startIndex,
                    endIndex,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                foundKeyWords.add(keyWord)
                startIndex = currentPartText.indexOf(keyWord, startIndex + 1, ignoreCase = false)
            }
        }
        Log.d("KeywordSearch", "Found keywords in text: ${foundKeyWords.joinToString(", ")}, total=${foundKeyWords.size}")

        // Подсвечиваем текущее слово жёлтым фоном
        var startIndex = 0
        var wordCount = 0
        currentPartWords.forEach { word ->
            if (wordCount == currentWordIndex) {
                val endIndex = startIndex + word.length
                spannable.setSpan(
                    BackgroundColorSpan(Color.YELLOW),
                    startIndex,
                    endIndex,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                Log.d("KeywordSearch", "Highlighting word: '$word', start=$startIndex, end=$endIndex")
            }
            startIndex += word.length
            if (startIndex < currentPartText.length && currentPartText[startIndex] == ' ') {
                startIndex++ // Пропускаем пробел
            }
            wordCount++
        }

        textView.text = spannable
    }

    private fun startWordAnimation(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        guideView.visibility = View.INVISIBLE
        animator?.cancel()

        val layout = textView.layout
        if (layout == null) {
            Log.e("KeywordSearch", "TextView layout is null")
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val wordStartIndex = getWordStartIndex(currentWordIndex, currentPartText)
        val wordEndIndex = wordStartIndex + currentPartWords[currentWordIndex].length

        if (wordStartIndex < 0 || wordStartIndex >= currentPartText.length) {
            Log.e("KeywordSearch", "Invalid wordStartIndex: $wordStartIndex")
            currentWordIndex++
            animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
            return
        }

        val startLine = layout.getLineForOffset(wordStartIndex)
        val endLine = layout.getLineForOffset(wordEndIndex)
        val startX = layout.getPrimaryHorizontal(wordStartIndex)
        var endX = layout.getPrimaryHorizontal(wordEndIndex)
        if (endX == startX) {
            endX = startX + layout.getPrimaryHorizontal(wordStartIndex + 1)
        }
        val lineTop = layout.getLineTop(startLine).toFloat()
        val lineBottom = layout.getLineBottom(startLine).toFloat()
        val lineY = (lineTop + lineBottom) / 2 // Середина строки для guideView

        // Прокрутка ScrollView
        scrollView?.let { sv ->
            sv.post {
                val scrollViewHeight = sv.height
                val currentScrollY = sv.scrollY
                val lineTopPosition = layout.getLineTop(startLine)
                val lineBottomPosition = layout.getLineBottom(startLine)

                // Определяем видимую область (верхняя треть экрана)
                val visibleTop = currentScrollY
                val visibleBottom = currentScrollY + scrollViewHeight * 2 / 3

                // Прокручиваем, если строка не полностью видна
                if (lineTopPosition < visibleTop || lineBottomPosition > visibleBottom) {
                    // Цель: поставить строку в верхнюю треть экрана
                    val targetScrollY = (lineTopPosition - scrollViewHeight / 3).coerceAtLeast(0).toInt()
                    if (targetScrollY != lastScrollY) {
                        Log.d("KeywordSearch", "Attempting scroll for line $startLine, word='${currentPartWords[currentWordIndex]}'")
                        Log.d("KeywordSearch", "Scroll parameters: line=$startLine, word='${currentPartWords[currentWordIndex]}', lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, scrollViewHeight=$scrollViewHeight, currentScrollY=$currentScrollY, targetScrollY=$targetScrollY")
                        // Плавная прокрутка
                        ValueAnimator.ofInt(currentScrollY, targetScrollY).apply {
                            duration = wordDurationMs / 2 // Прокрутка быстрее анимации слова
                            addUpdateListener { animation ->
                                val value = animation.animatedValue as Int
                                sv.scrollTo(0, value)
                            }
                            addListener(
                                onEnd = {
                                    lastScrollY = targetScrollY
                                    Log.d("KeywordSearch", "Scrolled to line $startLine, targetScrollY=$targetScrollY, currentScrollY=${sv.scrollY}")
                                }
                            )
                            start()
                        }
                    } else {
                        Log.d("KeywordSearch", "No scroll needed, already at target: line=$startLine, word='${currentPartWords[currentWordIndex]}', targetScrollY=$targetScrollY")
                    }
                } else {
                    Log.d("KeywordSearch", "No scroll needed, line $startLine is visible, lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, visibleTop=$visibleTop, visibleBottom=$visibleBottom")
                }

                sv.postDelayed({
                    Log.d("KeywordSearch", "After scroll check, currentScrollY=${sv.scrollY}, textViewHeight=${textView.height}, scrollViewHeight=$scrollViewHeight")
                }, 100)
            }
        } ?: Log.e("KeywordSearch", "ScrollView is null, cannot scroll to line $startLine for word '${currentPartWords[currentWordIndex]}'")

        Log.d("KeywordSearch", "Animating word: '${currentPartWords[currentWordIndex]}' at position $currentWordIndex, startX=$startX, endX=$endX, lineY=$lineY, startLine=$startLine, endLine=$endLine, duration=$wordDurationMs ms")

        animator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = wordDurationMs
            addUpdateListener { animation ->
                val fraction = animation.animatedValue as Float
                val currentX = startX + (endX - startX) * fraction
                guideView.translationX = currentX - (guideView.width / 2) + textView.left
                guideView.translationY = lineY + textView.top.toFloat() - (scrollView?.scrollY?.toFloat() ?: 0f)
            }
            addListener(
                onEnd = {
                    currentWordIndex++
                    Log.d("KeywordSearch", "Word animation ended, currentWordIndex=$currentWordIndex")
                    animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
                }
            )
            start()
        }
    }

    private fun getWordStartIndex(wordIndex: Int, text: String): Int {
        var startIndex = 0
        var count = 0
        text.split("\\s+".toRegex()).forEachIndexed { index, word ->
            if (count == wordIndex) {
                return startIndex
            }
            startIndex += word.length
            if (startIndex < text.length && text[startIndex] == ' ') {
                startIndex++ // Пропускаем пробел
            }
            count++
        }
        return startIndex
    }
    override fun cancelAnimation() {
        animator?.cancel()
        Log.d("KeywordSearch", "Animation cancelled")
    }
}package com.example.scorochenie.domain

import android.animation.ValueAnimator
import android.graphics.Color
import android.text.Spannable
import android.text.SpannableString
import android.text.style.BackgroundColorSpan
import android.text.style.StyleSpan
import android.util.Log
import android.view.View
import android.widget.ScrollView
import android.widget.TextView
import androidx.core.animation.addListener
import android.graphics.Typeface

class PointerMethodTechnique : ReadingTechnique("Метод \"указки\"") {
    private var currentWordIndex = 0
    private var selectedTextIndex = 0
    private var fullText: String = ""
    private var animator: ValueAnimator? = null
    private var currentPartWords: List<String> = emptyList()
    private var currentPartText: String = ""
    private var scrollView: ScrollView? = null
    private var lastScrollY: Int = 0

    override val description: SpannableString
        get() {
            val text = "Метод \"указки\" — это техника скорочтения, в которой используется визуальное сопровождение текста для направления внимания. Вместо пальца или ручки, в приложении слова подсвечиваются по очереди, помогая глазам двигаться по строкам без остановок и возвратов.\n" +
                    "Такая подача помогает удерживать ритм чтения и повышает концентрацию на ключевых фразах.\n" +
                    "Следите за подсвеченными словами и старайтесь воспринимать информацию с их скоростью — это способствует более быстрому и осознанному чтению."
            val spannable = SpannableString(text)
            spannable.setSpan(StyleSpan(Typeface.BOLD), 0, name.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(Typeface.BOLD), text.indexOf("визуальное сопровождение текста"), text.indexOf("визуальное сопровождение текста") + "визуальное сопровождение текста".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(Typeface.BOLD), text.indexOf("за подсвеченными словами"), text.indexOf("за подсвеченными словами") + "за подсвеченными словами".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        }

    override fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,
        onAnimationEnd: () -> Unit
    ) {
        this.selectedTextIndex = selectedTextIndex
        fullText = TextResources.otherTexts["Метод указки"]?.getOrNull(selectedTextIndex)?.text?.replace("\n", " ") ?: ""
        currentWordIndex = 0
        lastScrollY = 0

        // Преобразуем WPM в миллисекунды на слово
        val wordDurationMs = (60_000 / durationPerWord).coerceAtLeast(50L) // Минимум 50 мс
        Log.d("PointerMethod", "Starting animation with durationPerWord=$durationPerWord WPM, wordDurationMs=$wordDurationMs ms")

        scrollView = textView.parent as? ScrollView
        Log.d("PointerMethod", "ScrollView initialized: $scrollView, parent=${textView.parent}, parentClass=${textView.parent?.javaClass?.simpleName}")
        if (scrollView == null) {
            Log.e("PointerMethod", "TextView is not inside a ScrollView, scrolling will not work")
        } else {
            Log.d("PointerMethod", "ScrollView height: ${scrollView?.height}, width: ${scrollView?.width}")
        }

        textView.gravity = android.view.Gravity.TOP
        textView.isSingleLine = false
        textView.maxLines = Int.MAX_VALUE
        textView.post {
            showNextTextPart(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun showNextTextPart(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        currentPartText = fullText
        currentPartWords = currentPartText.split("\\s+".toRegex()).filter { it.isNotEmpty() }
        currentWordIndex = 0

        Log.d("PointerMethod", "Showing full text: '$currentPartText', wordCount=${currentPartWords.size}")

        textView.text = currentPartText
        animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
    }

    private fun animateNextWord(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        if (currentWordIndex >= currentPartWords.size) {
            guideView.visibility = View.INVISIBLE
            Log.d("PointerMethod", "Text ended, stopping animation")
            animator?.cancel()
            textView.text = currentPartText
            onAnimationEnd()
            return
        }

        highlightWord(textView)
        startWordAnimation(textView, guideView, wordDurationMs, onAnimationEnd)
    }

    private fun highlightWord(textView: TextView) {
        val spannable = SpannableString(currentPartText)
        val existingSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
        for (span in existingSpans) {
            spannable.removeSpan(span)
        }

        var startIndex = 0
        var wordCount = 0

        currentPartWords.forEach { word ->
            if (wordCount == currentWordIndex) {
                val endIndex = startIndex + word.length
                spannable.setSpan(
                    BackgroundColorSpan(Color.YELLOW),
                    startIndex,
                    endIndex,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                Log.d("PointerMethod", "Highlighting word: '$word', start=$startIndex, end=$endIndex")
            }
            startIndex += word.length
            if (startIndex < currentPartText.length && currentPartText[startIndex] == ' ') {
                startIndex++ // Пропускаем пробел
            }
            wordCount++
        }

        textView.text = spannable
    }

    private fun startWordAnimation(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        guideView.visibility = View.INVISIBLE
        animator?.cancel()

        val layout = textView.layout
        if (layout == null) {
            Log.e("PointerMethod", "TextView layout is null")
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val wordStartIndex = getWordStartIndex(currentWordIndex, currentPartText)
        val wordEndIndex = wordStartIndex + currentPartWords[currentWordIndex].length

        if (wordStartIndex < 0 || wordStartIndex >= currentPartText.length) {
            Log.e("PointerMethod", "Invalid wordStartIndex: $wordStartIndex")
            currentWordIndex++
            animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
            return
        }

        val startLine = layout.getLineForOffset(wordStartIndex)
        val endLine = layout.getLineForOffset(wordEndIndex)
        val startX = layout.getPrimaryHorizontal(wordStartIndex)
        var endX = layout.getPrimaryHorizontal(wordEndIndex)
        if (endX == startX) {
            endX = startX + layout.getPrimaryHorizontal(wordStartIndex + 1)
        }
        val lineTop = layout.getLineTop(startLine).toFloat()
        val lineBottom = layout.getLineBottom(startLine).toFloat()
        val lineY = (lineTop + lineBottom) / 2 // Середина строки для guideView

        // Прокрутка ScrollView
        scrollView?.let { sv ->
            sv.post {
                val scrollViewHeight = sv.height
                val currentScrollY = sv.scrollY
                val lineTopPosition = layout.getLineTop(startLine)
                val lineBottomPosition = layout.getLineBottom(startLine)

                // Определяем видимую область (верхняя треть экрана)
                val visibleTop = currentScrollY
                val visibleBottom = currentScrollY + scrollViewHeight * 2 / 3

                // Прокручиваем, если строка не полностью видна
                if (lineTopPosition < visibleTop || lineBottomPosition > visibleBottom) {
                    // Цель: поставить строку в верхнюю треть экрана
                    val targetScrollY = (lineTopPosition - scrollViewHeight / 3).coerceAtLeast(0).toInt()
                    if (targetScrollY != lastScrollY) {
                        Log.d("PointerMethod", "Attempting scroll for line $startLine, word='${currentPartWords[currentWordIndex]}'")
                        Log.d("PointerMethod", "Scroll parameters: line=$startLine, word='${currentPartWords[currentWordIndex]}', lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, scrollViewHeight=$scrollViewHeight, currentScrollY=$currentScrollY, targetScrollY=$targetScrollY")
                        // Плавная прокрутка
                        ValueAnimator.ofInt(currentScrollY, targetScrollY).apply {
                            duration = wordDurationMs / 2 // Прокрутка быстрее анимации слова
                            addUpdateListener { animation ->
                                val value = animation.animatedValue as Int
                                sv.scrollTo(0, value)
                            }
                            addListener(
                                onEnd = {
                                    lastScrollY = targetScrollY
                                    Log.d("PointerMethod", "Scrolled to line $startLine, targetScrollY=$targetScrollY, currentScrollY=${sv.scrollY}")
                                }
                            )
                            start()
                        }
                    } else {
                        Log.d("PointerMethod", "No scroll needed, already at target: line=$startLine, word='${currentPartWords[currentWordIndex]}', targetScrollY=$targetScrollY")
                    }
                } else {
                    Log.d("PointerMethod", "No scroll needed, line $startLine is visible, lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, visibleTop=$visibleTop, visibleBottom=$visibleBottom")
                }

                sv.postDelayed({
                    Log.d("PointerMethod", "After scroll check, currentScrollY=${sv.scrollY}, textViewHeight=${textView.height}, scrollViewHeight=$scrollViewHeight")
                }, 100)
            }
        } ?: Log.e("PointerMethod", "ScrollView is null, cannot scroll to line $startLine for word '${currentPartWords[currentWordIndex]}'")

        Log.d("PointerMethod", "Animating word: '${currentPartWords[currentWordIndex]}' at position $currentWordIndex, startX=$startX, endX=$endX, lineY=$lineY, startLine=$startLine, endLine=$endLine, duration=$wordDurationMs ms")

        animator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = wordDurationMs
            addUpdateListener { animation ->
                val fraction = animation.animatedValue as Float
                val currentX = startX + (endX - startX) * fraction
                guideView.translationX = currentX - (guideView.width / 2) + textView.left
                guideView.translationY = lineY + textView.top.toFloat() - (scrollView?.scrollY?.toFloat() ?: 0f)
            }
            addListener(
                onEnd = {
                    currentWordIndex++
                    Log.d("PointerMethod", "Word animation ended, currentWordIndex=$currentWordIndex")
                    animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
                }
            )
            start()
        }
    }

    private fun getWordStartIndex(wordIndex: Int, text: String): Int {
        var startIndex = 0
        var count = 0
        text.split("\\s+".toRegex()).forEachIndexed { index, word ->
            if (count == wordIndex) {
                return startIndex
            }
            startIndex += word.length
            if (startIndex < text.length && text[startIndex] == ' ') {
                startIndex++ // Пропускаем пробел
            }
            count++
        }
        return startIndex
    }
    override fun cancelAnimation() {
        animator?.cancel()
        Log.d("PointerMethod", "Animation cancelled")
    }
}package com.example.scorochenie.domain

import android.text.SpannableString
import android.view.View
import android.widget.TextView

abstract class ReadingTechnique(val name: String) {
    open val description: SpannableString = SpannableString("")

    abstract fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,  // новый параметр
        onAnimationEnd: () -> Unit
    )
    open fun cancelAnimation() {
        // Пустая реализация по умолчанию для техник без анимации
    }
}
package com.example.scorochenie.domain

import android.animation.ValueAnimator
import android.graphics.Color
import android.text.Spannable
import android.text.SpannableString
import android.text.style.BackgroundColorSpan
import android.text.style.StyleSpan
import android.util.Log
import android.view.View
import android.widget.ScrollView
import android.widget.TextView
import androidx.core.animation.addListener

class SentenceReverseTechnique : ReadingTechnique("Предложения наоборот") {
    private var currentSentenceIndex = 0
    private var currentWordIndexInSentence = 0
    private var selectedTextIndex = 0
    private var fullText: String = ""
    private var currentPosition = 0
    private var animator: ValueAnimator? = null
    private var sentences: List<List<String>> = emptyList()
    private var sentenceStartIndices: List<Int> = emptyList()
    private var scrollView: ScrollView? = null
    private var lastScrollY: Int = 0

    override val description: SpannableString
        get() {
            val text = "Предложения наоборот — это техника скорочтения, направленная на формирование навыка правильного чтения и профилактику «зеркального» чтения. Текст читается, начиная с последнего слова каждого предложения.\n" +
                    "Для применения техники начинайте с последнего слова предложения и двигайтесь к первому.\n" +
                    "Сосредоточьтесь на правильном порядке чтения слов, чтобы улучшить внимание и навыки чтения."
            val spannable = SpannableString(text)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), 0, name.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("начинайте с последнего слова"), text.indexOf("начинайте с последнего слова") + "начинайте с последнего слова".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            spannable.setSpan(StyleSpan(android.graphics.Typeface.BOLD), text.indexOf("правильном порядке чтения"), text.indexOf("правильном порядке чтения") + "правильном порядке чтения".length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        }

    override fun startAnimation(
        textView: TextView,
        guideView: View,
        durationPerWord: Long,
        selectedTextIndex: Int,
        onAnimationEnd: () -> Unit
    ) {
        this.selectedTextIndex = selectedTextIndex
        fullText = reverseSentences(TextResources.otherTexts["Предложения наоборот"]?.getOrNull(selectedTextIndex)?.text?.replace("\n", " ") ?: "")
        currentPosition = 0
        currentSentenceIndex = 0
        currentWordIndexInSentence = 0
        lastScrollY = 0

        // Преобразуем WPM в миллисекунды на слово
        val wordDurationMs = (60_000 / durationPerWord).coerceAtLeast(50L)
        Log.d("SentenceReverse", "Starting animation with durationPerWord=$durationPerWord WPM, wordDurationMs=$wordDurationMs ms")

        scrollView = textView.parent as? ScrollView
        Log.d("SentenceReverse", "ScrollView initialized: $scrollView, parent=${textView.parent}, parentClass=${textView.parent?.javaClass?.simpleName}")
        if (scrollView == null) {
            Log.e("SentenceReverse", "TextView is not inside a ScrollView, scrolling will not work")
        } else {
            Log.d("SentenceReverse", "ScrollView height: ${scrollView?.height}, width: ${scrollView?.width}")
        }

        textView.gravity = android.view.Gravity.TOP
        textView.isSingleLine = false
        textView.maxLines = Int.MAX_VALUE
        textView.post {
            Log.d("SentenceReverse", "Full text length: ${fullText.length}")
            Log.d("SentenceReverse", "TextView height: ${textView.height}, width: ${textView.width}, lineCount: ${textView.lineCount}")
            showText(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun showText(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        if (currentPosition >= fullText.length) {
            guideView.visibility = View.INVISIBLE
            Log.d("SentenceReverse", "Text ended, stopping animation")
            animator?.cancel()
            textView.text = fullText
            onAnimationEnd()
            return
        }

        textView.text = fullText
        sentences = parseSentences(fullText)
        sentenceStartIndices = calculateSentenceStartIndices(fullText, sentences)

        val currentSentence = sentences.getOrNull(currentSentenceIndex)
        currentWordIndexInSentence = if (currentSentence.isNullOrEmpty()) -1 else currentSentence.size - 1

        Log.d("SentenceReverse", "Showing text: '$fullText'")
        Log.d("SentenceReverse", "Sentences: ${sentences.map { it.joinToString(" ") }}")
        Log.d("SentenceReverse", "Sentence start indices: $sentenceStartIndices")
        Log.d("SentenceReverse", "Initial currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence, currentSentence=${currentSentence?.joinToString(" ")}")
        if (currentSentence != null && currentWordIndexInSentence >= 0) {
            Log.d("SentenceReverse", "Starting with word: '${currentSentence[currentWordIndexInSentence]}' at position $currentWordIndexInSentence")
        }

        textView.post {
            animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun parseSentences(text: String): List<List<String>> {
        val sentences = mutableListOf<List<String>>()
        val wordRegex = Regex("""\b\w+\b""")
        val sentenceRegex = Regex("([^.!?()]+[.!?])")

        sentenceRegex.findAll(text).forEach { matchResult ->
            val sentenceText = matchResult.value.trim()
            val words = wordRegex.findAll(sentenceText)
                .map { it.value }
                .filter { it.isNotEmpty() }
                .toList()
            if (words.isNotEmpty()) {
                sentences.add(words)
                Log.d("SentenceReverse", "Parsed sentence: ${words.joinToString(" ")} (word count: ${words.size})")
            }
        }

        if (sentences.isEmpty()) {
            Log.w("SentenceReverse", "No sentences parsed from text: $text")
            val words = wordRegex.findAll(text)
                .map { it.value }
                .filter { it.isNotEmpty() }
                .toList()
            if (words.isNotEmpty()) {
                sentences.add(words)
                Log.d("SentenceReverse", "Fallback parsed sentence: ${words.joinToString(" ")} (word count: ${words.size})")
            }
        }

        Log.d("SentenceReverse", "Parsed sentences: ${sentences.map { it.joinToString(" ") }}")
        return sentences
    }

    private fun calculateSentenceStartIndices(text: String, sentences: List<List<String>>): List<Int> {
        val indices = mutableListOf<Int>()
        var currentIndex = 0
        sentences.forEach { sentence ->
            indices.add(currentIndex)
            sentence.forEach { word ->
                var wordIndex = text.indexOf(word, currentIndex)
                while (wordIndex != -1) {
                    val isWordStart = wordIndex == 0 || !text[wordIndex - 1].isLetterOrDigit()
                    val wordEnd = wordIndex + word.length
                    val isWordEnd = wordEnd == text.length || !text[wordEnd].isLetterOrDigit()
                    if (isWordStart && isWordEnd) {
                        break
                    }
                    wordIndex = text.indexOf(word, wordIndex + 1)
                }
                if (wordIndex == -1) {
                    Log.e("SentenceReverse", "Word '$word' not found from index $currentIndex in text: $text")
                    return@forEach
                }
                currentIndex = wordIndex + word.length
                while (currentIndex < text.length && text[currentIndex] == ' ') {
                    currentIndex++
                }
            }
            while (currentIndex < text.length && !text[currentIndex].isLetterOrDigit()) {
                currentIndex++
            }
        }
        Log.d("SentenceReverse", "Sentence start indices: $indices")
        return indices
    }

    private fun reverseSentences(text: String): String {
        val sentenceRegex = Regex("([^.!?]+)([.!?])")
        return sentenceRegex.findAll(text).joinToString(" ") { matchResult ->
            val body = matchResult.groupValues[1].trim()
            val endPunct = matchResult.groupValues[2]
            val tokenRegex = Regex("""\w+|[^\s\w]""")
            val tokens = tokenRegex.findAll(body).map { it.value }.toList()

            val wordChunks = mutableListOf<WordChunk>()
            var i = 0
            while (i < tokens.size) {
                val tok = tokens[i]
                if (tok.any { it.isLetterOrDigit() }) {
                    val puncts = mutableListOf<String>()
                    var j = i + 1
                    while (j < tokens.size && !tokens[j].any { it.isLetterOrDigit() }) {
                        puncts.add(tokens[j])
                        j++
                    }
                    wordChunks.add(WordChunk(tok, puncts))
                    i = j
                } else {
                    if (wordChunks.isNotEmpty()) {
                        wordChunks.last().punctuation.add(tok)
                    }
                    i++
                }
            }

            val sb = StringBuilder()
            for ((word, puncts) in wordChunks.asReversed()) {
                for (p in puncts) {
                    sb.append(p)
                }
                if (sb.isNotEmpty() && sb.last() != ' ' && sb.last() !in listOf('-', '—', '–', ',', '.', '!', '?')) {
                    sb.append(' ')
                }
                sb.append(word)
                sb.append(' ')
            }

            var sent = sb.toString().trim()
            val wordPattern = Regex("""\b([a-zA-Zа-яА-ЯёЁ]+)\b""")
            val lastWordMatch = wordPattern.findAll(sent).lastOrNull()
            if (lastWordMatch != null) {
                val lastWord = lastWordMatch.value
                val range = lastWordMatch.range
                val correctedLastWord = lastWord.replaceFirstChar { it.lowercaseChar() }
                sent = sent.substring(0, range.start) + correctedLastWord + sent.substring(range.endInclusive + 1)
            }

            val finalSent = sent.replaceFirstChar { it.uppercaseChar() }
            "$finalSent$endPunct"
        }
    }

    private fun animateNextWord(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        Log.d("SentenceReverse", "animateNextWord: currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence")

        if (currentSentenceIndex >= sentences.size) {
            Log.d("SentenceReverse", "No more sentences to display, ending animation")
            guideView.visibility = View.INVISIBLE
            animator?.cancel()
            textView.text = fullText
            onAnimationEnd()
            return
        }

        val currentSentence = sentences.getOrNull(currentSentenceIndex)
        if (currentSentence == null || currentSentence.isEmpty() || currentWordIndexInSentence < 0) {
            currentSentenceIndex++
            val nextSentence = sentences.getOrNull(currentSentenceIndex)
            currentWordIndexInSentence = if (nextSentence.isNullOrEmpty()) -1 else nextSentence.size - 1
            Log.d("SentenceReverse", "Moving to next sentence: currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence, nextSentence=${nextSentence?.joinToString(" ")}")
            if (nextSentence != null && currentWordIndexInSentence >= 0) {
                Log.d("SentenceReverse", "Starting with word: '${nextSentence[currentWordIndexInSentence]}' at position $currentWordIndexInSentence")
            }
            textView.post { animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }
            return
        }

        Log.d("SentenceReverse", "Starting sentence: ${currentSentence.joinToString(" ")} (word count: ${currentSentence.size})")
        Log.d("SentenceReverse", "Current word: '${currentSentence[currentWordIndexInSentence]}' at position $currentWordIndexInSentence")

        textView.post {
            highlightWord(textView)
            startWordAnimation(textView, guideView, wordDurationMs, onAnimationEnd)
        }
    }

    private fun highlightWord(textView: TextView) {
        val spannable = SpannableString(fullText)
        val existingSpans = spannable.getSpans(0, spannable.length, BackgroundColorSpan::class.java)
        for (span in existingSpans) {
            spannable.removeSpan(span)
        }

        val currentSentence = sentences.getOrNull(currentSentenceIndex)
        if (currentSentence == null || currentSentence.isEmpty() || currentWordIndexInSentence < 0 || currentWordIndexInSentence >= currentSentence.size) {
            Log.e("SentenceReverse", "Invalid sentence or word index: currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence, sentence=${currentSentence?.joinToString(" ")}")
            return
        }

        val word = currentSentence[currentWordIndexInSentence]
        val sentenceStartIndex = sentenceStartIndices.getOrNull(currentSentenceIndex) ?: 0
        val sentenceEndIndex = if (currentSentenceIndex + 1 < sentenceStartIndices.size) {
            sentenceStartIndices[currentSentenceIndex + 1]
        } else {
            fullText.length
        }
        val wordStartIndex = findWordStartIndex(word, sentenceStartIndex, sentenceEndIndex, currentSentence, currentWordIndexInSentence)

        if (wordStartIndex >= 0 && wordStartIndex < fullText.length) {
            val endIndex = wordStartIndex + word.length
            if (endIndex <= fullText.length) {
                spannable.setSpan(
                    BackgroundColorSpan(Color.YELLOW),
                    wordStartIndex,
                    endIndex,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
                Log.d("SentenceReverse", "Highlighting word: '$word' at position $currentWordIndexInSentence, start=$wordStartIndex, end=$endIndex")
            } else {
                Log.e("SentenceReverse", "Invalid end index: $endIndex for word: '$word'")
            }
        } else {
            Log.e("SentenceReverse", "Invalid word start index: $wordStartIndex for word: '$word'")
        }

        textView.text = spannable
    }

    private fun findWordStartIndex(word: String, startIndex: Int, endIndex: Int, sentence: List<String>, wordPosition: Int): Int {
        if (startIndex < 0 || startIndex >= fullText.length || endIndex > fullText.length || startIndex >= endIndex) {
            Log.e("SentenceReverse", "Invalid indices: startIndex=$startIndex, endIndex=$endIndex")
            return -1
        }

        val sentenceText = fullText.substring(startIndex, endIndex)
        Log.d("SentenceReverse", "Current sentence text: '$sentenceText'")
        Log.d("SentenceReverse", "Current sentence: ${sentence.joinToString(" ")}")

        var currentIndex = startIndex
        var currentWordIdx = 0
        while (currentIndex < endIndex && currentWordIdx <= wordPosition) {
            while (currentIndex < endIndex && !fullText[currentIndex].isLetterOrDigit()) {
                currentIndex++
            }
            if (currentIndex >= endIndex) break

            val currentWord = sentence[currentWordIdx]
            val isWordStart = currentIndex == 0 || !fullText[currentIndex - 1].isLetterOrDigit()
            val wordEnd = currentIndex + currentWord.length
            val isWordEnd = wordEnd >= fullText.length || !fullText[wordEnd].isLetterOrDigit()
            if (isWordStart && isWordEnd && fullText.substring(currentIndex, wordEnd) == currentWord) {
                if (currentWordIdx == wordPosition) {
                    return currentIndex
                }
                currentIndex = wordEnd
                currentWordIdx++
            } else {
                while (currentIndex < endIndex && fullText[currentIndex].isLetterOrDigit()) {
                    currentIndex++
                }
            }
        }

        Log.e("SentenceReverse", "Word '$word' at position $wordPosition not found in sentence text: '$sentenceText'")
        return -1
    }

    private fun startWordAnimation(
        textView: TextView,
        guideView: View,
        wordDurationMs: Long,
        onAnimationEnd: () -> Unit
    ) {
        guideView.visibility = View.INVISIBLE
        animator?.cancel()

        val layout = textView.layout
        if (layout == null) {
            Log.e("SentenceReverse", "TextView layout is null")
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val currentSentence = sentences.getOrNull(currentSentenceIndex)
        if (currentSentence == null || currentSentence.isEmpty() || currentWordIndexInSentence < 0 || currentWordIndexInSentence >= currentSentence.size) {
            Log.e("SentenceReverse", "Invalid sentence or word index: currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence, sentence=${currentSentence?.joinToString(" ")}")
            currentWordIndexInSentence--
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val word = currentSentence[currentWordIndexInSentence]
        val sentenceStartIndex = sentenceStartIndices.getOrNull(currentSentenceIndex) ?: 0
        val sentenceEndIndex = if (currentSentenceIndex + 1 < sentenceStartIndices.size) {
            sentenceStartIndices[currentSentenceIndex + 1]
        } else {
            fullText.length
        }
        val wordStartIndex = findWordStartIndex(word, sentenceStartIndex, sentenceEndIndex, currentSentence, currentWordIndexInSentence)

        if (wordStartIndex < 0 || wordStartIndex >= fullText.length) {
            Log.e("SentenceReverse", "Invalid wordStartIndex: $wordStartIndex for word: '$word'")
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val wordEndIndex = wordStartIndex + word.length
        if (wordEndIndex > fullText.length) {
            Log.e("SentenceReverse", "Invalid wordEndIndex: $wordEndIndex for word: '$word'")
            textView.postDelayed({ animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd) }, 200)
            return
        }

        val startLine = layout.getLineForOffset(wordStartIndex)
        val endLine = layout.getLineForOffset(wordEndIndex)
        val startX = layout.getPrimaryHorizontal(wordStartIndex)
        var endX = layout.getPrimaryHorizontal(wordEndIndex)
        if (endX == startX) {
            endX = startX + layout.getPrimaryHorizontal(wordStartIndex + 1)
        }
        val lineTop = layout.getLineTop(startLine).toFloat()
        val lineBottom = layout.getLineBottom(startLine).toFloat()
        val lineY = (lineTop + lineBottom) / 2 // Середина строки для guideView

        // Прокрутка ScrollView
        scrollView?.let { sv ->
            sv.post {
                val scrollViewHeight = sv.height
                val currentScrollY = sv.scrollY
                val lineTopPosition = layout.getLineTop(startLine)
                val lineBottomPosition = layout.getLineBottom(startLine)

                // Определяем видимую область (верхняя треть экрана)
                val visibleTop = currentScrollY
                val visibleBottom = currentScrollY + scrollViewHeight * 2 / 3

                // Прокручиваем, если строка не полностью видна
                if (lineTopPosition < visibleTop || lineBottomPosition > visibleBottom) {
                    // Цель: поставить строку в верхнюю треть экрана
                    val targetScrollY = (lineTopPosition - scrollViewHeight / 3).coerceAtLeast(0).toInt()
                    if (targetScrollY != lastScrollY) {
                        Log.d("SentenceReverse", "Attempting scroll for line $startLine, word='$word'")
                        Log.d("SentenceReverse", "Scroll parameters: line=$startLine, word='$word', lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, scrollViewHeight=$scrollViewHeight, currentScrollY=$currentScrollY, targetScrollY=$targetScrollY")
                        // Плавная прокрутка
                        ValueAnimator.ofInt(currentScrollY, targetScrollY).apply {
                            duration = wordDurationMs / 2 // Прокрутка быстрее анимации слова
                            addUpdateListener { animation ->
                                val value = animation.animatedValue as Int
                                sv.scrollTo(0, value)
                            }
                            addListener(
                                onEnd = {
                                    lastScrollY = targetScrollY
                                    Log.d("SentenceReverse", "Scrolled to line $startLine, targetScrollY=$targetScrollY, currentScrollY=${sv.scrollY}")
                                }
                            )
                            start()
                        }
                    } else {
                        Log.d("SentenceReverse", "No scroll needed, already at target: line=$startLine, word='$word', targetScrollY=$targetScrollY")
                    }
                } else {
                    Log.d("SentenceReverse", "No scroll needed, line $startLine is visible, lineTop=$lineTopPosition, lineBottom=$lineBottomPosition, visibleTop=$visibleTop, visibleBottom=$visibleBottom")
                }

                sv.postDelayed({
                    Log.d("SentenceReverse", "After scroll check, currentScrollY=${sv.scrollY}, textViewHeight=${textView.height}, scrollViewHeight=$scrollViewHeight")
                }, 100)
            }
        } ?: Log.e("SentenceReverse", "ScrollView is null, cannot scroll to line $startLine for word '$word'")

        Log.d("SentenceReverse", "Animating word: '$word' at position $currentWordIndexInSentence, startX=$startX, endX=$endX, lineY=$lineY, startLine=$startLine, endLine=$endLine, duration=$wordDurationMs ms")

        animator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = wordDurationMs
            addUpdateListener { animation ->
                val fraction = animation.animatedValue as Float
                val currentX = startX + (endX - startX) * fraction
                guideView.translationX = currentX - (guideView.width / 2) + textView.left
                guideView.translationY = lineY + textView.top.toFloat() - (scrollView?.scrollY?.toFloat() ?: 0f)
                Log.d("SentenceReverse", "guideView position: translationX=${guideView.translationX}, translationY=${guideView.translationY}, scrollY=${scrollView?.scrollY}")
            }
            addListener(
                onEnd = {
                    currentWordIndexInSentence--
                    Log.d("SentenceReverse", "Word animation ended, currentSentenceIndex=$currentSentenceIndex, currentWordIndexInSentence=$currentWordIndexInSentence")
                    animateNextWord(textView, guideView, wordDurationMs, onAnimationEnd)
                }
            )
            start()
        }
    }
    override fun cancelAnimation() {
        animator?.cancel()
        Log.d("SentenceReverse", "Animation cancelled")
    }
    data class WordChunk(val word: String, val punctuation: MutableList<String>)
}package com.example.scorochenie.domain

data class Technique(val name: String, val description: String? = null)package com.example.scorochenie.domain

// Базовый класс для текстов, только текст и вопросы
data class TextData(
    val text: String,
    val questionsAndAnswers: List<Pair<String, List<String>>>
)

// Текст для "Чтение по диагонали" с breakWords
data class DiagonalTextData(
    val text: String,
    val breakWords: List<String>,
    val questionsAndAnswers: List<Pair<String, List<String>>>
)

// Текст для "Поиск ключевых слов" с keyWords
data class KeywordTextData(
    val text: String,
    val keyWords: List<String>,
    val questionsAndAnswers: List<Pair<String, List<String>>>
)

object TextResources {
    // Карта для "Чтение по диагонали" (с breakWords)
    val diagonalTexts = listOf(
        DiagonalTextData(
            text = """
                Зелёные растения – единственный вид живых существ, способный самостоятельно производить свою пищу. Растение получают пищу из воды, углекислого газа и минералов почвы, также они используют энергию Солнца. Этот процесс называется фотосинтезом. В результате также выделяется кислород, необходимый для всех живых существ. Животные пользуются пищей, созданной растениями, поедая растения или тех животных, которые питаются этими растениями. Без растений все животные и люди должны были бы умереть. Первые растения представляли собой отдельные клетки, плававшие в океане, покрывавшем всю землю. Постепенно некоторые клетки образовали соединения, каждое с особой задачей. Корень – чтобы удерживать растение на месте; стебель – чтобы обеспечить процесс фотосинтеза и размножение. Водоросли остались простейшими. Когда растения выбрались на землю, им пришлось приспособиться к жизни на суше без поддержки воды. Стебли растений становились толще, и у них развился корень. Первые наземные растения обитали лишь в сырых местах, однако нынешние растения распространены в разных местах: от границ арктических льдов до тропических джунглей. Первыми растениями, распространёнными на новой территории, были лишайники. Они нарастают, словно кора, на обнажённой поверхности скал. Умирая, они сгнивают и превращаются в первый слой почвы. На этом слое почвы вырастают мхи, и их смерть и разложение, в свою очередь, формирует второй слой почвы. Вскоре почвы становится достаточно, чтобы росли папоротники и цветковые растения. Таким образом развивается сообщество растений, обеспечивая пищей животных и образуя единую среду обитания. Ботаникам известно около 380000 видов растений. Большинство из них можно найти в тропических лесах. Из 250000 видов цветковых растений 90000 принадлежат к флоре Центральной и Южной Америки, а ещё 30000 – к флоре тропической Африки. Далее на север разнообразие растений уменьшается. В Великобритании насчитывается всего 1800 видов. Растения закрепляются практически везде на нашей планете. Однако их благополучию угрожают люди в своих поисках пищи, топлива и пространства для жизни.
            """.trimIndent(),
            breakWords = listOf(". Они"),
            questionsAndAnswers = listOf(
                "Как называется процесс, с помощью которого растения производят себе пищу?" to listOf("фотосинтез", "испарение", "брожение"),
                "Какие три вещества растения используют для питания?" to listOf("вода, углекислый газ, минералы", "кислород, азот, свет", "белки, жиры, углеводы"),
                "Кто был первым живым организмом, подготовившим почву для других растений?" to listOf("лишайники", "папоротники", "мхи"),
                "Где на Земле встречается наибольшее разнообразие растений?" to listOf("тропические леса", "арктические пустыни", "горные вершины"),
                "Что угрожает благополучию растений?" to listOf("деятельность человека", "изменения орбиты Земли", "движения тектонических плит")
            )
        ),
        DiagonalTextData(
            text = """
                Если ты включишь радио, то услышишь человека, который говорит в сотнях и тысячах миль от тебя. Звук не распространяется так далеко. Чтобы направлять поток волн, используется передатчик. Радиоприёмник улавливает радиоволны и использует их для того, чтобы передать копию первоначального звука. Когда человек говорит в микрофон, его голос воспроизводит вибрацию воздуха. Микрофон превращает вибрацию в слабый переменный электрический ток, то есть в электрические сигналы. Электрические сигналы поступают на передатчик, который превращает их в радиоволны, заставляя ток резко подниматься и опускаться по антенне. Радиоволны выходят из передатчика в виде единого потока, это несущая волна. В простейших типах передатчиков сигналы из микрофона контролируют мощность испускаемых радиоволн. Это значит, что радиоволны пульсируют, меняя свою мощность, в соответствии со звуковой вибрацией. Такое управление радиоволнами называется манипулирование амплитудой. Пульсирующие радиоволны передатчика, радиосигналы, улавливаются антенной приёмника. Приёмник превращает волны вновь в электросигналы, которые поступают вновь в громкоговоритель. Громкоговоритель воспроизводит в воздухе точно такие же вибрации, как те, которые поступали в микрофон, так что мы слышим копию первоначального звука. Передатчики каждую секунду передают миллионы разных волн. Количество волн в секунду называется частотой. Она отмечена на шкале настройки радиоприёмника либо в килогерцах (тысяча волн в секунду), либо в мегагерцах (в миллионах волн в секунду). Различные станции используют различные частоты, поэтому, чтобы выбрать ту, которая тебе нужна, надо настроить приёмник. Радиоволны используются во многих других средствах коммуникации, кроме просто передачи звука. Полиция, пожарные, таксисты и врачи «скорой помощи» используют двухстороннее радио, чтобы переговариваться со штабом и друг с другом. Радиотелефон подключается к телефону сети через радио. Корабли и самолёты тоже используют радио для переговоров и ориентации, поскольку по сигналу радиомаяка они определяют своё местонахождение. Телевидение применяет радиоволны для передачи звука и изображения. По радио можно управлять большими космическими кораблями, моделями автомашин, лодками и самолётами. Некоторые радиоволны проходят тысячи километров вокруг земли, двигаясь между ионосферой и поверхностью земли. Они мчатся со скоростью 290000 (двести девяносто тысяч) километров в секунду. Мы не успеем и глазом моргнуть, как радиоволны совершат кругосветное путешествие.
            """.trimIndent(),
            breakWords = listOf("которые поступали в", "290000"),
            questionsAndAnswers = listOf(
                "Что используется для преобразования звуковых вибраций в электрические сигналы?" to listOf("микрофон", "антенна", "динамик"),
                "Как называется процесс управления мощностью радиоволн в соответствии с вибрацией звука?" to listOf("манипулирование амплитудой", "электромагнитное торможение", "вибрационное кодирование"),
                "В чём измеряется частота радиоволн?" to listOf("в килогерцах и мегагерцах", "в метрах и литрах", "в паскалях и ньютонах"),
                "Почему приёмник может принимать только одну нужную станцию?" to listOf("потому что он настраивается на определённую частоту", "потому что звук изолируется микрофоном", "потому что приёмник имеет один динамик"),
                "Для чего используются радиоволны, помимо передачи звука?" to listOf("для связи, телевидения и управления", "только для освещения", "только для обогрева воздуха")
            )
        ),
        DiagonalTextData(
            text = """
                Радар позволяет нам обнаружить положение неподвижного объекта, даже если он находится очень далеко или в темноте. Радар необходим для авиадиспетчеров, которые с его помощью определяют высоту самолёта и место, где он находится, далеко ли от аэропорта. С помощью радара и другие виды транспорта могут двигаться, не рискуя столкнуться. Радар может рассмотреть очень маленькие предметы размером с насекомых или большие, величиной с гору. Для прогнозирования погоды используются радары, которые могут обнаружить приближение грозовой тучи или урагана. Учёные применяют радар для изучения атмосферы и других планет. Он также необходим для космических полётов: с помощью радара диспетчер на Земле может проследить путь ракеты до выхода за орбиту. Радар широко применяется в военных целях, поскольку он может предупредить о приближении вражеских ракет, самолётов или субмарин. Работа радара похожа на звуковое эхо, он обнаруживает объекты, посылая в их сторону микроволны. Передатчик радара направляет микроволны в небо. Когда волны натыкаются на какое-то препятствие, например, на самолёт, часть их отражается назад, к радарной тарелке, она передаёт их на приёмное устройство, которое преобразует волны в электрический сигнал. Учитывая промежуток времени, который понадобился для возвращения отражённых волн, лазерная установка определяет расстояние до самолёта. Местонахождение самолёта высвечивается как яркое или мигающее пятно на дисплее. Антенны радара вращаются так, чтобы охватить волнами весь горизонт. Почти все большие самолёты снабжены радарами, предупреждающими их о находящихся поблизости самолётах и о надвигающемся шторме. Радар на борту корабля посылает микроволны вдоль поверхности воды так, чтобы они отразились от любого корабля или неожиданного препятствия на пути судна. Первую радарную установку создал учёный Роберт Ватсон-Ватт. В 1935 году Британское правительство поручило Ватсон-Ватту изобрести "лучи смерти" для отражения атак вражеских самолётов. Это оказалось невозможным, но, исследуя данную идею, учёный изобрёл радар для обнаружения вражеских самолётов. Многие люди считают, что радар сыграл очень важную роль во Второй мировой войне.
            """.trimIndent(),
            breakWords = listOf("сигнал."),
            questionsAndAnswers = listOf(
                "Какой принцип используется в работе радара?" to listOf("отражение микроволн (эхо)", "испарение частиц", "гравитационное притяжение"),
                "Кто изобрёл первую радарную установку?" to listOf("Роберт Ватсон-Ватт", "Альберт Эйнштейн", "Никола Тесла"),
                "Для чего авиадиспетчеры используют радар?" to listOf("для определения положения и высоты самолёта", "для измерения температуры в салоне", "для подсчёта пассажиров"),
                "Как радар определяет расстояние до объекта?" to listOf("по времени возвращения отражённых волн", "по весу объекта", "по цвету изображения на дисплее"),
                "В каком году была создана первая радарная установка?" to listOf("в 1935 году", "в 1912 году", "в 1960 году")
            )
        )
    )

    // Карта для "Поиск ключевых слов" (с keyWords)
    val keywordTexts = listOf(
        KeywordTextData(
            text = """
                 Разные человеческие болезни, такие, как нарывы, пищевые отравления, воспаление легких или тиф, вызываются особыми возбудителями, бактериями. Человек, заболевший бактериальным заболеванием, обычно передает его другому, значит, эти заболевания заразны. Другие люди также подвергаются риску, и поэтому особенно важно вылечить эти болезни. Антибиотик – это лекарство, которое применяют врачи, чтобы вылечить эти болезни. Антибиотик – это естественный продукт, выделяемый грибками. Эти вещества могут служить защитой против бактерий. Антибиотики по-разному вредят бактериям и убивают их. Одни мешают бактерии выстроить собственный оборонительный вал. Без этого специального слоя бактерия взрывается. Другие антибиотики препятствуют бактериям вырабатывать протеин, которым они питаются, и без протеина бактерии умирают. Пока не были изобретены антибиотики, инфекционные заболевания убивали тысячи людей. Людям приходилось заводить огромные семьи, чтобы возместить эти утраты. Теперь большинство этих болезней можно вылечить, но поскольку лекарства дороги, только богатые страны могут широко применять их. Доктор Александр Флеминг открыл первый антибиотик пенициллин благодаря счастливой случайности, когда занимался в своей лаборатории выращиванием бактерий. Споры плесени по ошибке попали в колбу с бактериями, и он заметил, что там, где вырастала плесень, бактерии погибали.
            """.trimIndent(),
            keyWords = listOf(
                "бактерии", "антибиотик", "пенициллин", "Александр Флеминг", "инфекционные заболевания",
                "плесень", "протеин", "грибки", "заразные болезни", "иммунная система"
            ),
            questionsAndAnswers = listOf(
                "Что вызывает бактериальные заболевания?" to listOf("бактерии", "вирусы", "грибки"),
                "Как называется первый антибиотик, открытый Флемингом?" to listOf("пенициллин", "тетрациклин", "аспирин"),
                "Как антибиотики убивают бактерии?" to listOf("мешают строить защитный слой или вырабатывать протеин", "нагревают их", "изменяют их цвет"),
                "Кто открыл пенициллин?" to listOf("Александр Флеминг", "Луи Пастер", "Роберт Кох"),
                "Почему антибиотики не применялись повсеместно раньше?" to listOf("их не было до открытия пенициллина", "они были слишком дешёвыми", "их запрещали")
            )
        ),
        KeywordTextData(
            text = """
                  Большинство людей, говоря о соли, имеют в виду то вещество, которое мы используем при приготовлении пищи. Однако учёные называют солью большое количество химических веществ, в том числе и обыкновенную соль. Соль образуется, когда атом водорода в кислоте вытесняется металлом. Все соли состоят из кристаллов. Столовая соль представляет собой белые кристаллы кубической формы. В химии столовая соль называется хлоридом натрия. Это один из самых полезных минералов на земле. На сегодняшний день для соли нашли более 16.000 (шестнадцати тысяч) способов применения. Кроме приготовления пищи, производства других химических веществ, соль используется в пищевой промышленности, для сохранения мяса, рыбы и овощей, а также при изготовлении таких продуктов, как масло и маргарин. Соль применяется при изготовлении керамики и лекарств. Соль нужна, чтобы зимой чистить дороги и тротуары от снега и льда. Чистая вода замерзает при температуре 0° (ноль градусов) Цельсия или 32° (тридцать два) градуса по Фаренгейту, но солёная вода замерзает при гораздо более низкой температуре, она растворяет снег и лёд и препятствует их замерзанию. Небольшое количество соли необходимо для правильного функционирования организма. Мы должны употреблять в пищу соль, потому что организм постоянно её расходует, например, соль выходит с по том во время работы или занятий спортом. Чтобы остаться здоровыми, нам нужно примерно полграмма соли в день, если мы не слишком потеем. Однако в среднем взрослый человек съедает в день от 5 до 20 граммов соли, то есть в 20 раз больше, чем нужно. Врачи считают, что излишек соли повышает риск сердечных заболеваний. На нашей планете много соли, но её добыть нелегко. Каменная соль – это, как правило, самая обычная соль, она залегает толстыми слоями глубоко под землёй. Эти слои сформировались очень давно, когда высохли доисторические моря. Знаменитые соляные копи находятся в России, Англии и Канаде. Иногда каменную соль добывают, просто выкапывая её из-под земли, но чаще в шахту закачивают воду или пар, создавая соляной раствор. Затем его выкачивают на поверхность и выпаривают воду, оставляя соль. В некоторых жарких странах соль добывают, отводя морскую воду в пруды. Когда морская вода испаряется, на дне остаётся морская соль. В 5 литрах морской воды содержится около 100 граммов соли.
            """.trimIndent(),
            keyWords = listOf(
                "соль", "хлорид натрия", "кристаллы", "каменная соль", "морская соль",
                "пищевая промышленность", "добыча соли", "сердечные заболевания", "соляные копи", "замерзание воды"
            ),
            questionsAndAnswers = listOf(
                "Как называется столовая соль в химии?" to listOf("хлорид натрия", "оксид кальция", "сульфат магния"),
                "Для чего соль используется зимой?" to listOf("для очистки дорог от снега и льда", "для обогрева домов", "для полива растений"),
                "Как добывают каменную соль?" to listOf("выкапывают или выпаривают из раствора", "извлекают из воздуха", "фильтруют из рек"),
                "Почему избыток соли вреден?" to listOf("повышает риск сердечных заболеваний", "вызывает аллергию", "замедляет рост"),
                "Где содержится морская соль?" to listOf("в морской воде", "в почве", "в воздухе")
            )
        ),
        KeywordTextData(
            text = """
                     Измерив температуру предмета, мы узнаём, насколько он горяч. Но это не скажет нам, какой у него запас тепла. К примеру, раскалённая искра гораздо горячее чашки чая. Чашка чая больше, и потому в ней больше запас тепла. Температура и тепло – не одно и то же. Для измерения температуры применяется термометр, шкалу, которой пользуются для измерения. Большинство стран пользуется шкалой Цельсия, то есть стоградусной шкалой. Замерзание воды обозначено как 0° (ноль градусов), а точка кипения соответствует 100° (ста градусам). Иногда в прогнозах погоды или в рецептах указывается шкала Фаренгейта. На этой шкале вода замерзает при 32° (тридцати двух), а кипит при 212° (двухстах двенадцати) градусах. В тёплый день температура поднимается до 20° (двадцати градусов) Цельсия или 70° (семидесяти) по Фаренгейту. Долина смерти в Калифорнии – одно из самых жарких мест на земле. Температура там поднимается выше 45° (сорока пяти градусов) по Цельсию. Немногие существа могут выжить в таких условиях. Озеро Байкал в Сибири – одно из самых холодных мест на земле, зимой температура здесь опускается ниже 50° (пятидесяти) градусов по Цельсию. Существуют различные виды термометров. Некоторые используют спирт или жидкую ртуть, которые расширяются при нагревании. Как только температура поднимается, жидкость на конце термометра расширяется, поднимаясь по узкой трубке. Уровень жидкости соответствует определённому градусу на шкале. Некоторые термометры представляют собой ряд квадратов на полоске бумаги. Квадраты пропитаны различными химическими веществами, которые меняют цвет при определённой температуре. Существуют и электрические термометры, они состоят из небольшого зонда, присоединённого проводами к измерительному прибору. Когда температура меняется, меняется и сила тока в зонде. Электрические термометры широко применяются в промышленности и медицине. Температуру можно контролировать с помощью термостатов. Самое обычное место их применения – центральное отопление. Термостат располагается на стене и удерживает постоянную температуру автоматически, включая и отключая электричество. Термостат встроен в большинство утюгов, духовок, холодильников и морозильных камер. Когда утюг достаточно разогрет, термостат отключает его от сети и вновь включает его в сеть, когда утюг остывает. Многие термостаты имеют внутри биметаллическую полоску, состоящую из двух спаянных воедино кусков разных металлов. Когда температура повышается, биметаллическая полоска разогревается, и один металл расширяется сильнее, чем другой. В результате этого полоска искривляется, контакты расходятся, и электрический ток прерывается. Когда температура падает, биметаллическая полоска выпрямляется, и контакты вновь соприкасаются, электрический ток возобновляется. Термостаты контролируют не только электрический ток, в газовой духовке они контролируют поток газа.
                """.trimIndent(),
            keyWords = listOf(
                "температура", "термометр", "шкала Цельсия", "шкала Фаренгейта", "термостат",
                "биметаллическая полоска", "тепло", "Долина смерти", "Озеро Байкал", "электрические термометры"
            ),
            questionsAndAnswers = listOf(
                "Что измеряет термометр?" to listOf("температуру", "вес", "давление"),
                "При какой температуре замерзает вода по Цельсию?" to listOf("0 градусов", "32 градуса", "100 градусов"),
                "Как работает биметаллическая полоска в термостате?" to listOf("искривляется при нагреве, размыкая контакты", "нагревает воздух", "меняет цвет"),
                "Где находится одно из самых жарких мест на Земле?" to listOf("Долина смерти", "Озеро Байкал", "Сибирь"),
                "Для чего используются электрические термометры?" to listOf("в промышленности и медицине", "в кулинарии", "в строительстве")
            )
        )
    )

    val otherTexts = mapOf(
        "Чтение блоками" to listOf(
            TextData(
                text = """
                    Мы со всех сторон окружены смесью газов, которой мы дышим и которую называем воздухом. Мы не можем нюхать воздух или пробовать его на вкус, но когда поднимается ветер, мы чувствуем, как движется воздух. Без воздуха наша планете была бы пустой, безводной и безжизненной пустыней. Воздух в основном состоит из двух газов: кислорода (21%) и азота (78%). Есть ещё небольшое количество (менее 1%) аргона и ещё меньшие запасы углекислого газа, а также некоторых других газов. Углекислый газ очень нужен, поскольку им питаются зелёные растения. Растения нуждаются в углекислом газе, воде, минералах и энергии солнечного света, чтобы приготовить себе пищу. Этот процесс называется фотосинтезом. Он также служит для производства кислорода. В воздухе есть ещё множество других веществ: пыль, водяной пар, пыльца, семена, микроскопические животные, бактерии и газообразные промышленные отходы. Знаете ли вы, что ведро воздуха весит примерно столько же, сколько две страницы книги? Кажется, не так уж и много, но это означает, что в таком большом пространстве, как школьный зал, может поместиться более тонны воздуха, а это уже вес небольшого автомобиля. Вес воздуха всегда давит на нас сверху, но он не расплющивает нас, потому что воздух есть и внутри. Давление атмосферного воздуха может слегка колебаться, и это один из факторов, влияющих на погоду. Атмосферное давление можно измерить с помощью барометра. Падение давления предупреждает нас, что может начаться дождь. А высокое давление обычно означает, что погода будет хорошая. Давление воздуха можно увеличить, закачав больше воздуха в определённое пространство. В шины нужно закачать дополнительно воздух, тогда они смогут выдержать велосипед, машину и даже самолёт. Сжатый воздух действует в тормозах поездов и грузовиков. Реактивные самолёты также используют воздух. Они получают разгон благодаря тому, что засасывают большие массы воздуха, а затем выбрасывают его с большой скоростью.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Из каких основных газов состоит воздух?" to listOf("кислород и азот", "водород и гелий", "углекислый газ и аргон"),
                    "Что растения используют для фотосинтеза?" to listOf("углекислый газ, вода, минералы, солнечный свет", "кислород, азот, пыль", "протеины, жиры, витамины"),
                    "Как называется прибор для измерения атмосферного давления?" to listOf("барометр", "термометр", "гигрометр"),
                    "Что указывает на возможный дождь?" to listOf("падение атмосферного давления", "повышение температуры", "увеличение влажности"),
                    "Где используется сжатый воздух?" to listOf("в шинах и тормозах", "в батареях", "в лампах")
                )
            ),
            TextData(
                text = """
                    Из клеток состоят живые организмы и растения. Микробы и простейшие растения и животные, такие, как амёба, состоят лишь из одной клетки. Большинство живых существ состоит из большого количества клеток, которые соединяются друг с другом. К примеру, наши тела состоят из миллиардов клеток, которые можно увидеть только под мощным микроскопом. Большинство клеток устроено одинаково. Каждая из них окружена клеточной мембраной, которая удерживает её составные части. Внутри мембраны клетка делится на два составных отдела: ядро и цитоплазму. Ядро содержит гены. Гены – это химические инструкции, которые регулируют создание клетки, её функции и размножение. Цитоплазма – это желе, содержащее сотни химических соединений. Клетки используют их для производства новых материалов или получения энергии. Растительные клетки также имеют ядро и цитоплазму. Они окружены плотной стеной, которая называется целлюлозой. Внутри растительной клетки находятся зелёные хлоропласты, содержащие хлорофилл. Хлорофилл улавливает энергию Солнца, которая в соединении с водой и углекислым газом даёт растениям пищу. Этот процесс называется фотосинтезом. Группа клеток называется тканью. Клетки, составляющие ткань, принадлежат одному виду. Например, ткань сердечного мускула состоит из клеток, содержащих волокна протеина, которые могут сокращаться, когда получают от нервов сигнал в виде электрического импульса. Ткань нервов состоит из нервных клеток. К телу каждой клетки прикреплены длинные тонкие волокна, передающие нервные импульсы. Клетки размножаются делением. Гены, которые находятся в клеточном ядре, соединяются в длинные нити. Они называются хромосомами. Когда клетка готова к делению, каждая хромосома делится на две, и тогда в клетке появляется два полных набора хромосом. Затем ядро и цитоплазма делятся, и каждая половина получает полный набор генов клетки. Таким образом клетки размножаются, а растения и животные могут расти или заменять старые ткани.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Что окружает клетку и удерживает её составные части?" to listOf("Клеточная мембрана", "Цитоплазма", "Хлоропласт"),
                    "Как называется процесс, при котором растения производят пищу, используя энергию Солнца?" to listOf("Фотосинтез", "Дыхание", "Деление клеток"),
                    "Что содержится в ядре клетки?" to listOf("Гены", "Хлорофилл", "Целлюлоза"),
                    "Как называется плотная стена, окружающая растительные клетки?" to listOf("Целлюлоза", "Клеточная мембрана", "Хромосома"),
                    "Как называются нити, в которые соединяются гены перед делением клетки?" to listOf("Хромосомы", "Волокна протеина", "Нервные импульсы")
                )
            ),
            TextData(
                text = """
                    Как и большинство наземных животных, люди дышат воздухом. Дыхание должно продолжаться всё время, пока мы живём. Каждую минуту мы вдыхаем и выдыхаем примерно 12 раз. Дыхание – это процесс поглощения воздуха лёгкими и выбрасывание его из лёгких. Лёгкие находятся в груди, они соединяются с гортанью трубкой, которая называется трахеей. Проходя через нос или рот, воздух попадает в трахею. При вдохе объём груди увеличивается, и воздух засасывается в лёгкие. Это происходит, когда мускулы приподнимают рёбра и выгибают их наружу, а специальный мускул, находящийся под лёгкими (он называется диафрагмой), опускается вниз. При выдохе рёбра опускаются, а диафрагма приподнимается. Мускулы рёбер расслабляются, и рёбра опускаются. Грудь уменьшается в объёме, а поскольку грудь становится меньше, воздух выдавливается из лёгких. Лёгкие взрослого человека могут вместить 5 литров воздуха, но при нормальном дыхании вдыхается и выдыхается лишь пол-литра воздуха. Мы дышим всё время, потому что нашему организму нужен постоянный запас кислорода. Мы используем кислород, чтобы выделить энергию из своей пищи. Этот процесс называется окислением. Мы должны дышать также и для того, чтобы избавиться от углекислого газа, который является отходами процесса дыхания. При физических упражнениях нам нужно больше энергии для мускулов, чем в обычное время. Поэтому приходится дышать быстрее, чтобы получить больше кислорода и выделить больше энергии из пищи, находящейся в нашем организме. Мы, как и другие наземные живые существа, получаем кислород из воздуха. Из вдыхаемого воздуха кислород поступает в кровяные тельца (тельца крови), которые обращаются в кровеносных сосудах вокруг сердца. Кровь приносит кислород в каждую клетку тела, здесь происходит процесс окисления, то есть кислород соединяется с частицами пищи и выделяет энергию. Затем кровь выносит выделившийся углекислый газ обратно в лёгкие, чтобы выбросить его из организма. В организме любого животного процесс окисления производит тепло. Хладнокровные животные, например, черепахи, тоже получают небольшое количество тепла от окисления.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Какой процесс происходит в лёгких во время дыхания?" to listOf("поглощение и выбрасывание воздуха", "переваривание пищи", "очищение крови"),
                    "Какая трубка соединяет лёгкие с гортанью?" to listOf("трахея", "пищевод", "аорта"),
                    "Что заставляет грудь увеличиваться при вдохе?" to listOf("мускулы рёбер и диафрагма", "сердце", "позвоночник"),
                    "Зачем организму нужен кислород?" to listOf("для выделения энергии из пищи", "для охлаждения тела", "для роста костей"),
                    "Что выводится из организма при выдохе?" to listOf("углекислый газ", "азот", "водород")
                )
            )
        ),
        "Предложения наоборот" to listOf(
            TextData(
                text = """
                    Когда мы фотографируем какой-то предмет или человека, мы получаем двухмерное картинку. Если мы сделаем голограмму какого-то предмета или человека, изображение получится трёхмерным. Это означает, что голограмма имеет глубину. Мы можем осмотреть предмет со всех сторон, словно он перед нами. Для создания голограммы нужен специальный одноцветный луч лазера. Лазерный луч расщепляется на две половины. Одна половина направляется на объект, который отражает свет лазера. Этот свет смешивается со второй половиной луча, он называется референтный луч. И они создают узор, который называется интерференционной полосой. Голограмма – это фотография интерференционных полос, она не похожа на исходный объект. На пластинке с голограммой ничего увидеть нельзя. Чтобы разглядеть спрятанную в голограмме картинку, надо направить на неё луч света, причём, точно такой же луч, какой был использован при получении голограммы. Тогда, глядя сквозь голограмму, мы увидим предмет так, словно он и в самом деле стоит перед нами. Хотя только в одном цвете, цвете лазерного луча. Некоторые голограммы можно разглядеть и без лазера, при обычном освещении. Голограммы используются не только ради красивых картинок, но и, например, при заводском контроле. Они обнаруживают даже маленькие различия между одинаковыми предметами. Голография используется в космических кораблях, чтобы проверить надёжность всех деталей. Некоторые голограммы основаны на отражённом свете. Они используются в кредитных карточках. Трёхмерное изображение, которое легко разглядеть, поворачивая карточку к свету, очень трудно подделать.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Что отличает голограмму от фотографии?" to listOf("трёхмерное изображение", "чёрно-белый цвет", "меньший размер"),
                    "Что нужно для создания голограммы?" to listOf("одноцветный лазерный луч", "обычная лампа", "цветной свет"),
                    "Как называется узор, создаваемый лучами в голограмме?" to listOf("интерференционная полоса", "спектральная линия", "волновой контур"),
                    "Где используются голограммы для проверки деталей?" to listOf("в космических кораблях", "в автомобилях", "в бытовой технике"),
                    "Почему голограммы на кредитных карточках трудно подделать?" to listOf("из-за трёхмерного изображения", "из-за их размера", "из-за их веса")
                )
            ),
            TextData(
                text = """
                Вакуум – это абсолютно пустое пространство, из которого удалён воздух. Учёные не могут создать полный вакуум. Самый чистый вакуум находится в космосе, но и там встречаются частицы газа и пыли. Когда мы говорим о вакууме, мы обычно подразумеваем частичный вакуум, который получается при удалении большей части воздуха. Давление атмосферы старается закачать в вакуум воздух или жидкость. Так происходит, когда ты втягиваешь в себя напиток через соломинку. Ты засасываешь в себя воздух, создавая частичный вакуум. Атмосфера давит на напиток в твоём стакане, вынуждая его подняться по соломинке. Частичный вакуум в термосе сохраняет температуру напитка. Напиток наливают в бутылки с двойными стеклянными стенками. Большую часть воздуха между стенками выкачали, создав частичный вакуум с низкой теплопроводностью. Однако часть тепла излучается и в этом вакууме, но блестящие поверхности стен отражают его обратно. Несколько часов питьё остаётся горячим или холодным в зависимости от того, каким оно было изначально. Вакуумный пылесос засасывает грязь и пыль с мебели и пола. Его мотор вращает вентилятор, создавая внутри частичный вакуум. Воздух снаружи рядом с отверстием засасывается внутрь пылесоса, унося с собой грязь и пыль. Пыль поступает по трубке в мешок, который служит фильтром. Грязь остаётся там, а воздух уходит. Некоторые пылесосы надо толкать по полу, и у них есть вращающаяся щётка, которая собирает грязь. В другие пылесосы грязь засасывается через отверстие на конце длинной гибкой трубы.
            """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Что такое вакуум?" to listOf("пустое пространство без воздуха", "жидкость под давлением", "смесь газов"),
                    "Как создаётся частичный вакуум в соломинке?" to listOf("при втягивании воздуха", "при нагревании жидкости", "при сжатии соломинки"),
                    "Для чего используется вакуум в термосе?" to listOf("сохранение температуры напитка", "увеличение веса термоса", "очистка жидкости"),
                    "Как работает вакуумный пылесос?" to listOf("засасывает грязь за счёт частичного вакуума", "нагревает воздух", "выталкивает пыль наружу"),
                    "Что задерживает грязь в пылесосе?" to listOf("фильтр-мешок", "вентилятор", "стеклянная стенка")
                )
            ),
            TextData(
                text = """
                 Бактерии живут всюду: в почве, в море, в воздухе. Это очень маленькие, микроскопические организмы. Бактерии существуют на коже человека и даже свободно парят в воздухе. В точке, которую мы нарисуем карандашом, может поместиться около сотни бактерий. По внешнему виду бактерии бывают самые разные, и их на земле столько, что их совокупный вес больше, чем вес всех живых существ, вместе взятых. Бактерии размножаются, постоянно делясь надвое. Это происходит так быстро, что за сутки одна бактерия может превратиться в тысячи миллионов. Бактерии принадлежат к числу древнейших обитателей земли. На севере, во льдах учёные нашли бактерии, жившие три миллиарда лет назад. Некоторые бактерии могут питаться, используя солнечную энергию. Этот процесс называется фотосинтезом. Но большинство живут на живых растениях и животных или в их останках, когда те умирают. Некоторые бактерии уничтожают мертвые растения и животных. Это полезно, потому что они способствуют возвращению ценных питательных веществ в почву, и таким образом растения могут использовать их для своего роста. Однако некоторые бактерии бывают вредны нам, потому что вызывают пищевые отравления и наиболее опасные для людей болезни, такие, как туберкулез, пневмония, холера и тиф. Вредоносные бактерии называются также микробами. Их можно убить антисептиками или лекарствами, которые называются антибиотиками. Вирусы намного меньше бактерий. Их действие заключается в том, что они внедряются в клетки и мешают их нормальной работе. Вирусы вызывают целый ряд заболеваний, от легких, таких, как самая обыкновенная простуда, до смертельных, таких, как бешенство и СПИД. Как правило, против вирусов нельзя использовать обычные антибиотики. Однако когда вирусы попадают в организм, иммунная система сама производит антитела, особого рода защитную систему, которая старается их уничтожить. Вакцина содержит мертвые или обезвреженные вирусы, подобные болезнетворным, она стимулирует иммунную систему производить антитела, так что в случае, если позднее на организм нападут вредоносные микробы, он будет отчасти подготовлен. Знаменитый ученый Луи Пастер открыл, что многие болезни вызываются бактериями. Он показал, что микробы переносят инфекцию от одного человека к другому. И он создал спасающие жизнь прививки.
            """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Как размножаются бактерии?" to listOf("делением надвое", "спорами", "почкованием"),
                    "Что делают полезные бактерии с мёртвыми растениями?" to listOf("возвращают питательные вещества в почву", "превращают их в газ", "окрашивают их"),
                    "Какие болезни могут вызывать вредные бактерии?" to listOf("туберкулёз и пневмония", "грипп и простуда", "аллергия и астма"),
                    "Как называются лекарства, убивающие бактерии?" to listOf("антибиотики", "вакцины", "анальгетики"),
                    "Кто открыл, что бактерии вызывают болезни?" to listOf("Луи Пастер", "Александр Флеминг", "Роберт Кох")
                )
            )
        ),
        "Слова наоборот" to listOf(
            TextData(
                text = """
                    Нас со всех сторон окружают газы. Воздух, которым мы дышим, - это смесь газов. Газы, а отличие от твёрдых и жидких тел, заполняют любую ёмкость. Многие газы невидимы и не имеют запаха и вкуса. Газы, находящиеся в воздухе, применяются в производстве. Кислород составляет 21% воздуха. Большое количество кислорода используется для производства стали из железа. Кислород прокачивается сквозь расплавленное железо, чтобы выжечь примеси и превратить железо в сталь. Иногда кислород соединяется с другим газом ацетиленом и сжигается. Карбидное пламя настолько горячее, что в нём плавится сталь, поэтому оно используется для соединения кусков стали в производстве или для разрезания стали. Азот составляет 78% воздуха. В отличие от кислорода, он не поддерживает горение, поэтому азот часто используют для заполнения контейнеров с горючими материалами. Азот также используют во взрывчатых веществах. Взрывчатые вещества используются для поисков газовых и нефтяных месторождений. Воздух содержит также в небольших количествах другие газы, в том числе углекислый газ. Углекислый газ используется в огнетушителях, поскольку он тяжелее воздуха, и, отрезав доступ кислороду, помогает погасить огонь. Углекислый газ используется также в шипучих напитках. Он растворяется в жидкости под высоким давлением, а когда напиток разливают в стаканы, углекислый газ выходит пузырьками. Ещё один газ, содержащийся в воздухе, называется гелий. Он не горит, не виден и не имеет запаха. Поскольку он очень лёгок, его используют в шарах и современных дирижаблях. Одно время в дирижаблях использовался водород, но, к несчастью, он горюч, и после множества аварий люди поняли, что он слишком ненадёжен. Теперь водород применяется преимущественно в производстве пищи, например, маргарина. Его также используют вместе с азотом в производстве удобрений. Неон и другие редкие газы используется в трубках, которые светятся, если через них пропустить электрический ток. Неоновые трубки используют в рекламе, которая светится по ночам. Природный газ, который мы сжигаем в печах и плитах, получился, как и нефть, из останков животных и растений, которые обитали на Земле миллионы лет назад. Его извлекают из-под земли. Основная его составляющая – газ метан.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Какой газ составляет 78% воздуха?" to listOf("азот", "кислород", "углекислый газ"),
                    "Для чего используется кислород в производстве?" to listOf("для производства стали", "для охлаждения металлов", "для окраски тканей"),
                    "Почему углекислый газ применяют в огнетушителях?" to listOf("он тяжелее воздуха и гасит огонь", "он легче воздуха", "он нагревает огонь"),
                    "Какой газ используют в воздушных шарах?" to listOf("гелий", "водород", "метан"),
                    "Где применяют неоновые трубки?" to listOf("в светящейся рекламе", "в батареях", "в шинах")
                )
            ),
            TextData(
                text = """
                    Все живые существа способны к росту, но для этого им требуется пища. Растения и животные добывают свою пищу по-разному. Растениям нужен углекислый газ из воздуха, вода и минеральные соли из почвы, а также солнечный свет, чтобы получить пищу для роста. Животным тоже нужна вода, однако им нужно много таких сложных пищевых компонентов, как углеводы, протеины, жиры и витамины. Они могут получить их, лишь питаясь другими растениями, или животными, или тем и другим. Хотя они используют разную пищу, растут растения и животные одинаково. Для роста живые существа должны производить новые клетки. Пищу, которую они получают, они превращают в материал для новых клеток. Новые клетки образуются так: уже существующие клетки увеличиваются и делятся на две. Этот процесс называется клеточным делением. Чем быстрее происходит клеточное деление, тем быстрее растёт животное или растение. По мере того, как младенец превращается в ребёнка, а затем во взрослого человека, в его теле происходит размножение многих типов клеток. Большинство органов нашего тела строится из клеток, которые способны к росту и размножению. Животные в разные периоды своей жизни растут с разной скоростью. Человек быстрее всего растёт в младенчестве, затем скорость роста замедляется, а затем ещё один рывок происходит в подростковом возрасте. Различные части тела также растут с разной скоростью. К примеру, голова младенца после его рождения растёт медленнее тела. В растениях деление клеток происходит в специальных центрах роста. Они обычно находятся на концах веток и корней. В почках из новых клеток создаются очень маленькие листья и части стебля. Рост корня происходит благодаря быстрому делению клеток, находящихся у самого его конца. Затем они достигают полного своего размера, словно крохотные баллончики наполняются водой. Время, которое требуется животным разных видов для достижения зрелости, бывает разным. Обычно чем больше животное, тем дольше оно растёт. Изменение роста строго контролируется с тем, чтобы размер и формы растущего животного или растения стали такими, какими они должны быть. Ростом управляют гормоны. У животных и растений разные гормоны, но действуют одинаково, управляя созреванием вплоть до взрослого состояния и способности к размножению.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Что нужно растениям для роста?" to listOf("углекислый газ, вода, минералы", "кислород, азот, белки", "сахар, жиры, витамины"),
                    "Как называется процесс деления клеток?" to listOf("клеточное деление", "фотосинтез", "окисление"),
                    "Когда человек растёт быстрее всего?" to listOf("в младенчестве и подростковом возрасте", "во взрослом возрасте", "в старости"),
                    "Где происходит деление клеток в растениях?" to listOf("в центрах роста на концах веток и корней", "в листьях", "в стволе"),
                    "Что управляет ростом животных и растений?" to listOf("гормоны", "ферменты", "витамины")
                )
            ),
            TextData(
                text = """Линзы в очках - это стекло или пластмасса особой формы, которая искажает луч света. Существует два типа линз. Вогнутыми называются линзы, которые тоньше в середине. Эти линзы рассеивают лучи света. Выпуклая линза толще всего в середине. Когда луч света проходит через выпуклую линзу, он сужается до точки, в которой линза его фокусирует. Выпуклая линза может использоваться в качестве увеличительного стекла. Если держать такую линзу над газетой, мы увидим, как увеличиваются под ней слова. Если над теми же словами держать вогнутую линзу, мы увидим, как слова уменьшаются. Если держать вогнутую линзу перед листом картона, повернутого к окну, линза образует на картонке маленькое перевёрнутое изображение окна. Это изображение мы называем отражением. Выпуклые линзы находятся в наших глазах. Они создают на внутренней поверхности глаза изображение того, что мы видим. Это изображение перевёрнуто, но наш мозг привык к этому и воспринимает его как нормальное. Мы можем использовать линзы очков, чтобы исправить зрение. В нормальном глазу свет фокусируется на сетчатке. В близоруком глазу свет фокусируется впереди сетчатки. Это можно исправить с помощью вогнутых линз. В дальнозорком глазу фокусировка происходит позади сетчатки. Это исправляется выпуклыми линзами. Линзы находят много применений в нашей жизни. Они используются в фотографии, когда перевёрнутое изображение переводится на плёнку. Линзы используются в микроскопах, чтобы увеличить предметы, слишком маленькие для нашего зрения. Линзы используются в биноклях, чтобы увеличить отдалённые предметы. Очень удалённые предметы, например, планеты солнечной системы, можно рассмотреть с помощью телескопа. И в нём тоже находятся линзы.ю энергетику.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Какой тип линз толще в середине?" to listOf("выпуклые", "вогнутые", "плоские"),
                    "Что делает выпуклая линза с лучами света?" to listOf("фокусирует их в точке", "рассеивает их", "отражает их"),
                    "Как исправляют близорукость?" to listOf("вогнутыми линзами", "выпуклыми линзами", "плоскими линзами"),
                    "Где используются линзы в микроскопах?" to listOf("для увеличения маленьких предметов", "для уменьшения изображения", "для изменения цвета"),
                    "Какое изображение создают линзы в глазах?" to listOf("перевёрнутое", "увеличенное", "размытое")
                )
            )
        ),
        "Метод указки" to listOf(
            TextData(
                text = """
                    У нас дома есть много магнитов. В кухне они удерживают на месте дверь холодильника. Есть немало и других магнитов, которых мы не замечаем. Магниты есть в телевизорах или в таких приборах, как дрель. Магнитные силы исходят из двух точек, которые называются полюсами магнита. Один полюс "северный", а другой – "южный". Если сблизить два магнита "северными" полюсами, они попытаются разойтись, они отталкивают друг друга. То же самое происходит при сближении "южных" полюсов. Однако «северный» полюс и «южный» притягиваются. Полюса одного типа отталкиваются. Когда кусочек металла попадает в магнитное поле, он намагничивается и приобретает полюса, противоположные полюсам основного магнита. Вот почему он притягивается к магниту. Магниты притягивают некоторые металлы: железо, никель, кобальт и некоторые виды стали. Но существует много металлов, которые магнит не притягивают. Это медь, алюминий, бронза, золото, олово, серебро и свинец. Магнит притягивает оловянные консервные банки, потому что они сделаны из стали и только покрыты тонкой плёнкой олова. Материалы, которые притягиваются магнитом, сами превращаются в магниты. Если положить иголку возле магнита, она станет магнитом. Сталь останется намагниченной даже когда магнит уберут. Металлический гвоздь тоже намагничивается возле магнита, но он быстро утрачивает это свойство, когда магнит убирают. Магниты, способные сохранять свои свойства, называются постоянными магнитами. Большинство таких магнитов делают из стали, специальных металлических соединений или материалов, которые называются ферритами. Их делают в форме прутьев, подков или колец. Учёные полагают, что в таких материалах, как железо и сталь, каждая группа атомов является маленьким магнитом. В нормальном состоянии атомы располагаются во всех направлениях, их магнитные свойства гасятся, но если материал подвергается воздействию магнита, атомы выстраиваются в едином направлении, и металл становится большим магнитом.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Какие полюса магнита притягиваются?" to listOf("северный и южный", "северный и северный", "южный и южный"),
                    "Какие металлы притягиваются магнитом?" to listOf("железо, никель, кобальт", "медь, алюминий, золото", "свинец, серебро, бронза"),
                    "Что происходит с иголкой возле магнита?" to listOf("становится магнитом", "нагревается", "меняет цвет"),
                    "Как называются магниты, сохраняющие свои свойства?" to listOf("постоянные магниты", "временные магниты", "электромагниты"),
                    "Из чего делают большинство постоянных магнитов?" to listOf("сталь, ферриты", "медь, алюминий", "пластмасса, стекло")
                )
            ),
            TextData(
                text = """
                    Горение – это химический процесс. Когда некоторые газы соединяются с кислородом воздуха, они производят много тепла и крохотные частицы. Эти частицы поднимаются вверх, накаляясь докрасна и даже добела. Это мы называем языками пламени. Каким бы ни был исходный материал, прежде чем он сгорит, он должен превратиться в газ. Это относится и к жидкостям, таким, как парафин, и к твёрдому топливу. Сгорая, вещество превращается в газ. Фитиль свечи покрыт воском. Когда мы зажигаем свечу, часть воска плавится и высвобождает газ, который начинает гореть. Его горение плавит следующую порцию воска, который, в свою очередь, начинает кипеть и высвобождать газ. Этот цикл выделения тепла и выделения газа поддерживает горение свечи. Любой огонь горит таким же образом. Когда люди обжигают уголь, они обычно кладут вниз бумагу и дерево, а сверху уголь. Бумага легко воспламеняется, даже спичка может нагреть её до такой степени, что она начнёт выделять газ, который загорится. Горение бумаги нагреет дерево, оно выделит газ, который, в свою очередь, загорится. А дерево горит долго, и этого времени хватает для того, чтобы разогреть уголь. Как только уголь разгорится, он выделит горючие газы, которые дадут достаточно тепла, чтобы высвободить следующую порцию газа и так далее. Для огня требуются три вещи: топливо, жар и кислород. Если чего-то не хватает, огонь не разгорится. К примеру, одеяло или огнетушитель погасят пламя, перекрыв доступ кислорода из воздуха. Большую часть своей истории человечество пользовалось огнём. Индустриальная революция XIX (девятнадцатого) века в основном зависела от силы пара, который получали с помощью огня. Без этой энергии многие научные достижения оказались бы невозможными. Одно из наиболее важных человеческих открытий состоит в том, что с помощью огня можно обрабатывать металлы. Долгое время только огонь давал людям достаточно тепла для приготовления пищи и для того, чтобы согреться в холода. До открытия электричества огонь также давал людям свет с помощью газовых и керосиновых ламп. Сегодня мы всё ещё пользуемся огнём для получения большей части необходимой нам энергии. Тепло, выделяющееся при горении угля, нефти и газа, используется для получения пара, который вращает генераторы электростанций. Генераторы производят электричество, так что теперь энергия огня используется более безопасным и контролируемым способом.
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Что такое горение?" to listOf("химический процесс с выделением тепла", "физическое испарение", "механическое движение"),
                    "Что необходимо для горения?" to listOf("топливо, жар, кислород", "вода, свет, воздух", "металл, давление, холод"),
                    "Как свеча поддерживает горение?" to listOf("воск плавится и выделяет газ", "фитиль нагревается и горит", "воздух охлаждает воск"),
                    "Как гасит огонь одеяло?" to listOf("перекрывает доступ кислорода", "охлаждает топливо", "увеличивает жар"),
                    "Для чего использовался огонь в индустриальной революции?" to listOf("для получения пара", "для освещения улиц", "для зарядки батарей")
                )
            ),
            TextData(
                text = """
                    Чтобы выжить и преуспеть, животное каждую минуту должно знать, что происходит в окружающем мире. Без их информации животное не сможет найти пищу, партнёра, место обитания, уберечься от хищников. Жизненно важная информация поступает через органы чувств. Зрение сообщает животным, как выглядят разные вещи и где они. Слух также сообщает о местоположении разных вещей и помогает общаться. Запах и вкус помогают отличить хорошую пищу от ядовитой. Осязание сообщает животным, какова вещь на ощупь, и рассказывает о ближайшем окружении. Глаза видят, уши слышат, язык пробует на вкус, нос улавливает запахи, то есть вся поверхность тела животного является его органом осязания. Органы чувств по нервам передают информацию в мозг животного, который обрабатывает все поступившие сообщения и складывает их в картину окружающего мира. Животному нужна информация и об его собственном теле, чтобы оно правильно функционировало. Для того чтобы двигаться, ему надо знать, в каком положении находятся различные части тела по отношению друг к другу. Ощущение равновесия необходимо, чтобы сохранить прямое положение и получить информацию о том, что какая-то часть тела у него повреждена. Эту информацию поставляют особые внутренние органы чувств. У человека есть специальные клетки в мускулах и суставах, которые контролируют движение тела. Есть органы равновесия, подключённые к внутреннему уху, и почти всюду в теле есть клетки, чувствительные к боли. Органы чувств адаптируются к образу жизни. У некоторых животных обыкновенные органы чувств могут быть всерхчувствительными в соответствии с их образом жизни. А другие животные развивают особые органы чувств. Летучие мыши находят дорогу в кромешной тьме, испуская высокочастотный звук, который они используют в качестве радара. Акулы ищут добычу в темноте, ориентируясь по исходящим от неё электрическим сигналам. Усики самца бабочки Императора так чувствительны к запаху самки, что он может обнаружить её в радиусе 11 километров. Разве это не удивительно?
                """.trimIndent(),
                questionsAndAnswers = listOf(
                    "Для чего животным нужны органы чувств?" to listOf("для получения информации об окружающем мире", "для хранения энергии", "для изменения цвета"),
                    "Какой орган отвечает за осязание?" to listOf("поверхность тела", "глаза", "уши"),
                    "Что делает мозг с информацией от органов чувств?" to listOf("обрабатывает и создаёт картину мира", "хранит её без изменений", "передаёт её обратно"),
                    "Как летучие мыши ориентируются в темноте?" to listOf("с помощью высокочастотного звука", "по запаху", "по свету"),
                    "Что чувствуют усики самца бабочки Императора?" to listOf("запах самки", "температуру воздуха", "вибрации почвы")
                )
            )
        )
    )
}package com.example.scorochenie.ui

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.util.AttributeSet
import android.util.Log
import android.view.View
import android.widget.TextView
import com.example.scorochenie.R

public class DiagonalLineView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private val paint = Paint().apply {
        color = Color.RED
        strokeWidth = 4f * resources.displayMetrics.density // 4dp
        style = Paint.Style.STROKE
        isAntiAlias = true
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        val width = measuredWidth
        val textView = (parent as View).findViewById<TextView>(R.id.animation_text_diagonal)
        val height = textView?.measuredHeight ?: 0
        setMeasuredDimension(width, height)
        Log.d("DiagonalLineView", "Measured size: ${width}x${height}")

        // Наблюдение за изменением размеров animationTextView
        if (textView != null) {
            textView.addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ ->
                if (textView.measuredHeight != measuredHeight) {
                    requestLayout()
                }
            }
        }
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        canvas.drawLine(0f, 0f, width.toFloat(), height.toFloat(), paint)
        Log.d("DiagonalLineView", "Drawing line with size: ${width}x${height}")
    }
}package com.example.scorochenie.ui

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.scorochenie.R
import android.widget.ImageView

class ExercisesFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_exercises, container, false)

        // Настройка RecyclerView
        val recyclerView = view.findViewById<RecyclerView>(R.id.exercises_list)
        recyclerView.layoutManager = LinearLayoutManager(context)
        // Добавляем разделитель
        val dividerItemDecoration = DividerItemDecoration(
            recyclerView.context,
            LinearLayoutManager.VERTICAL
        )
        recyclerView.addItemDecoration(dividerItemDecoration)
        // Список техник
        val techniques = listOf(
            TechniqueItem("DiagonalReadingTechnique", "Чтение по диагонали"),
            TechniqueItem("KeywordSearchTechnique", "Поиск ключевых слов"),
            TechniqueItem("BlockReadingTechnique", "Чтение \"блоками\""),
            TechniqueItem("SentenceReverseTechnique", "Предложения наоборот"),
            TechniqueItem("WordReverseTechnique", "Слова наоборот"),
            TechniqueItem("PointerMethodTechnique", "Метод \"указки\"")
        )

        // Установка адаптера
        recyclerView.adapter = TechniqueSelectionAdapter(techniques) { techniqueName ->
            navigateToSpeedSelection(techniqueName)
        }

        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // Настройка обработчика клика для иконки справки
        val helpIcon = view.findViewById<ImageView>(R.id.exercises_help_icon)
        helpIcon.setOnClickListener {
            showHelpDialog("Здесь вы найдете список упражнений для тренировки скорочтения. Погрузитесь в процесс и развивайте свои навыки чтения:\n" +
                    "1. Выберите технику: Определите, какую технику скорочтения вы хотите практиковать.\n" +
                    "2. Настройте скорость: Установите комфортный темп чтения для эффективной тренировки.\n" +
                    "3. Прочитайте текст: Внимательно ознакомьтесь с предложенным текстом.\n" +
                    "4. Ответьте на вопросы: Проверьте понимание материала, ответив на вопросы по тексту.")
        }
    }

    private fun showHelpDialog(message: String) {
        android.app.AlertDialog.Builder(requireContext())
            .setTitle("Справка")
            .setMessage(message)
            .setPositiveButton("ОК", null)
            .show()
    }

    private fun navigateToSpeedSelection(techniqueName: String) {
        val fragment = SpeedSelectionFragment.newInstance(techniqueName)
        parentFragmentManager.beginTransaction()
            .replace(R.id.fragment_container, fragment)
            .addToBackStack(null)
            .commit()
    }
}

// Временная data class для хранения информации о технике
data class TechniqueItem(val name: String, val displayName: String)package com.example.scorochenie.ui

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.scorochenie.R
import com.example.scorochenie.domain.Technique
import android.widget.ImageView

class MaterialsFragment : Fragment() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var techniqueAdapter: TechniqueAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_materials, container, false)

        recyclerView = view.findViewById(R.id.materials_list)
        recyclerView.layoutManager = LinearLayoutManager(context)

        // Добавляем разделитель
        val dividerItemDecoration = DividerItemDecoration(
            recyclerView.context,
            LinearLayoutManager.VERTICAL
        )
        recyclerView.addItemDecoration(dividerItemDecoration)

        val techniques = listOf(
            Technique("Чтение по диагонали"),
            Technique("Поиск ключевых слов"),
            Technique("Чтение \"блоками\""),
            Technique("Предложения наоборот"),
            Technique("Слова наоборот"),
            Technique("Метод \"указки\"")
        )

        techniqueAdapter = TechniqueAdapter(techniques) { technique ->
            onTechniqueClicked(technique)
        }
        recyclerView.adapter = techniqueAdapter

        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // Настройка обработчика клика для иконки справки
        val helpIcon = view.findViewById<ImageView>(R.id.materials_help_icon)
        helpIcon.setOnClickListener {
            showHelpDialog("Этот раздел создан, чтобы вы могли глубже изучить техники скорочтения и выбрать те, которые вам подходят! Ознакомьтесь с материалами, чтобы освоить новые навыки:\n" +
                    "1. Просмотрите, как работают техники: Узнайте, как каждая техника помогает читать быстрее и лучше понимать текст.\n" +
                    "2. Прочитайте описания техник: Изучите подробные инструкции и примеры, чтобы применять техники на практике.\n" +
                    "3. Начните изучение: Погрузитесь в материалы и тренируйтесь, чтобы сделать чтение более эффективным и увлекательным!")
        }
    }

    private fun showHelpDialog(message: String) {
        android.app.AlertDialog.Builder(requireContext())
            .setTitle("Справка")
            .setMessage(message)
            .setPositiveButton("ОК", null)
            .show()
    }

    private fun onTechniqueClicked(technique: Technique) {
        val detailFragment = TechniqueDetailFragment.newInstance(technique.name)
        parentFragmentManager.beginTransaction()
            .replace(R.id.fragment_container, detailFragment)
            .addToBackStack(null) // Добавляет возможность вернуться назад
            .commit()
    }
}package com.example.scorochenie.ui

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.example.scorochenie.data.TestResult
import com.example.scorochenie.databinding.ItemRatingBinding

class RatingAdapter : RecyclerView.Adapter<RatingAdapter.RatingViewHolder>() {

    private var results: List<TestResult> = emptyList()

    fun setResults(results: List<TestResult>) {
        this.results = results
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RatingViewHolder {
        val binding = ItemRatingBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return RatingViewHolder(binding)
    }

    override fun onBindViewHolder(holder: RatingViewHolder, position: Int) {
        holder.bind(results[position])
    }

    override fun getItemCount(): Int = results.size

    class RatingViewHolder(private val binding: ItemRatingBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(result: TestResult) {
            val techniqueDisplayName = when (result.techniqueName) {
                "BlockReadingTechnique" -> "Чтение \"блоками\""
                "DiagonalReadingTechnique" -> "Чтение по диагонали"
                "KeywordSearchTechnique" -> "Поиск ключевых слов"
                "PointerMethodTechnique" -> "Метод \"указки\""
                "SentenceReverseTechnique" -> "Предложения наоборот"
                "WordReverseTechnique" -> "Слова наоборот"
                else -> result.techniqueName
            }
            binding.tvTechniqueName.text = techniqueDisplayName
            binding.tvSpeed.text = "Скорость: ${result.durationPerWord} слов/мин"
            binding.tvScore.text = "Результат: ${result.score} из ${result.totalQuestions}"
        }
    }
}package com.example.scorochenie.ui

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import com.example.scorochenie.data.TestResult
import com.example.scorochenie.databinding.FragmentRatingBinding
import org.json.JSONObject

class RatingFragment : Fragment() {

    private var _binding: FragmentRatingBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapter: RatingAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentRatingBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        adapter = RatingAdapter()
        binding.ratingRecyclerView.adapter = adapter
        binding.ratingRecyclerView.layoutManager = LinearLayoutManager(context)

        // Добавляем разделитель
        val dividerItemDecoration = DividerItemDecoration(
            binding.ratingRecyclerView.context,
            LinearLayoutManager.VERTICAL
        )
        binding.ratingRecyclerView.addItemDecoration(dividerItemDecoration)

        loadBestResults()
        binding.ratingHelpIcon.setOnClickListener {
            showHelpDialog("Здесь вы можете увидеть свои достижения в тренировке скорочтения! Рейтинг отражает ваш лучший результат по каждой технике:\n" +
                    "1. Просмотрите лучшие результаты: Узнайте, сколько на вопросов вы правильно ответили для каждой техники.\n" +
                    "2. Оцените скорость чтения: Посмотрите, с какой скоростью был достигнут ваш лучший результат.\n" +
                    "3. Стремитесь к прогрессу: Практикуйтесь, чтобы улучшить свои показатели!")
        }

    }
    private fun showHelpDialog(message: String) {
        android.app.AlertDialog.Builder(requireContext())
            .setTitle("Справка")
            .setMessage(message)
            .setPositiveButton("ОК", null)
            .show()
    }

    private fun loadBestResults() {
        val sharedPreferences = requireContext().getSharedPreferences("TestResults", Context.MODE_PRIVATE)
        val allEntries = sharedPreferences.all

        // Собираем все результаты
        val results = mutableListOf<TestResult>()
        for (entry in allEntries) {
            val jsonString = entry.value as? String ?: continue
            try {
                val json = JSONObject(jsonString)
                val result = TestResult(
                    techniqueName = json.getString("techniqueName"),
                    durationPerWord = json.getLong("durationPerWord"),
                    score = json.getInt("score"),
                    totalQuestions = json.getInt("totalQuestions"),
                    timestamp = json.optLong("timestamp", 0L) // Используем optLong для обратной совместимости
                )
                results.add(result)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        // Группируем по методике, выбираем лучший результат по score, сортируем по последнему timestamp
        val bestResults = results.groupBy { it.techniqueName }
            .mapValues { entry ->
                entry.value.maxByOrNull { it.score }!! // Выбираем результат с максимальным score
            }
            .values
            .sortedByDescending { techniqueResults ->
                // Находим максимальный timestamp для этой методики
                results.filter { it.techniqueName == techniqueResults.techniqueName }
                    .maxOfOrNull { it.timestamp } ?: 0L
            }

        adapter.setResults(bestResults)
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}package com.example.scorochenie.ui

import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.fragment.app.Fragment
import com.example.scorochenie.databinding.FragmentReadingTestBinding
import kotlin.random.Random
import android.widget.TextView
import com.example.scorochenie.domain.BlockReadingTechnique
import com.example.scorochenie.domain.DiagonalReadingTechnique
import com.example.scorochenie.domain.KeywordSearchTechnique
import com.example.scorochenie.domain.PointerMethodTechnique
import com.example.scorochenie.R
import com.example.scorochenie.domain.ReadingTechnique
import com.example.scorochenie.domain.SentenceReverseTechnique
import com.example.scorochenie.domain.TextResources
import com.example.scorochenie.domain.WordReverseTechnique

class ReadingTestFragment : Fragment() {

    companion object {
        private const val ARG_TECHNIQUE_NAME = "technique_name"
        private const val ARG_DURATION_PER_WORD = "duration_per_word"
        fun newInstance(techniqueName: String, durationPerWord: Long): ReadingTestFragment {
            val fragment = ReadingTestFragment()
            val args = Bundle()
            args.putString(ARG_TECHNIQUE_NAME, techniqueName)
            args.putLong(ARG_DURATION_PER_WORD, durationPerWord)
            fragment.arguments = args
            return fragment
        }
    }

    private var _binding: FragmentReadingTestBinding? = null
    private val binding get() = _binding!!
    private lateinit var technique: ReadingTechnique
    private var durationPerWord: Long = 400L
    private var techniqueName: String = ""
    private var selectedTextIndex: Int = 0

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentReadingTestBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        techniqueName = arguments?.getString(ARG_TECHNIQUE_NAME) ?: ""
        durationPerWord = arguments?.getLong(ARG_DURATION_PER_WORD) ?: 400L

        // Нормализация имени техники
        val normalizedTechniqueName = when (techniqueName) {
            "DiagonalReadingTechnique" -> "Чтение по диагонали"
            "KeywordSearchTechnique" -> "Поиск ключевых слов"
            "BlockReadingTechnique" -> "Чтение блоками"
            "SentenceReverseTechnique" -> "Предложения наоборот"
            "WordReverseTechnique" -> "Слова наоборот"
            "PointerMethodTechnique" -> "Метод указки"
            else -> "Неизвестная техника"
        }

        // Инициализация техники
        technique = when (techniqueName) {
            "BlockReadingTechnique" -> BlockReadingTechnique()
            "DiagonalReadingTechnique" -> DiagonalReadingTechnique()
            "KeywordSearchTechnique" -> KeywordSearchTechnique()
            "PointerMethodTechnique" -> PointerMethodTechnique()
            "SentenceReverseTechnique" -> SentenceReverseTechnique()
            "WordReverseTechnique" -> WordReverseTechnique()
            else -> object : ReadingTechnique(normalizedTechniqueName) {
                override fun startAnimation(
                    textView: TextView,
                    guideView: View,
                    durationPerWord: Long,
                    selectedTextIndex: Int,
                    onAnimationEnd: () -> Unit
                ) {
                    textView.text = "Анимация недоступна"
                    guideView.visibility = View.INVISIBLE
                    onAnimationEnd()
                }
            }
        }

        // Выбираем размер списка текстов в зависимости от техники
        val textListSize = when (normalizedTechniqueName) {
            "Чтение по диагонали" -> TextResources.diagonalTexts.size
            "Поиск ключевых слов" -> TextResources.keywordTexts.size
            else -> TextResources.otherTexts[techniqueName]?.size ?: 1
        }
        selectedTextIndex = Random.nextInt(textListSize)

        if (normalizedTechniqueName == "Чтение по диагонали") {
            binding.scrollContainer.visibility = View.GONE
            binding.diagonalContainer.visibility = View.VISIBLE
            startReadingAnimation(binding.animationTextDiagonal)
        } else {
            binding.scrollContainer.visibility = View.VISIBLE
            binding.diagonalContainer.visibility = View.GONE
            startReadingAnimation(binding.animationTextScroll)
        }
    }

    private fun startReadingAnimation(textView: TextView) {
        val guideView = View(requireContext()).apply {
            visibility = View.INVISIBLE
            layoutParams = FrameLayout.LayoutParams(20, 2)
            setBackgroundColor(android.graphics.Color.BLACK)
        }

        val container = if (technique is DiagonalReadingTechnique) binding.diagonalContainer else binding.scrollContainer
        container.addView(guideView)

        technique.startAnimation(textView, guideView, durationPerWord, selectedTextIndex) {
            container.removeView(guideView)
            navigateToTest()
        }
    }

    private fun navigateToTest() {
        val fragment = TestFragment.newInstance(selectedTextIndex, techniqueName, durationPerWord)
        parentFragmentManager.beginTransaction()
            .replace(R.id.fragment_container, fragment)
            .addToBackStack(null)
            .commit()

    }

    override fun onDestroyView() {
        super.onDestroyView()
        technique.cancelAnimation()
        _binding = null
    }
}package com.example.scorochenie.ui

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.example.scorochenie.R
import com.example.scorochenie.databinding.FragmentSpeedSelectionBinding

class SpeedSelectionFragment : Fragment() {

    companion object {
        private const val ARG_TECHNIQUE_NAME = "technique_name"

        fun newInstance(techniqueName: String): SpeedSelectionFragment {
            return SpeedSelectionFragment().apply {
                arguments = Bundle().apply {
                    putString(ARG_TECHNIQUE_NAME, techniqueName)
                }
            }
        }
    }

    private var _binding: FragmentSpeedSelectionBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSpeedSelectionBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Получаем techniqueName из аргументов
        val techniqueName = arguments?.getString(ARG_TECHNIQUE_NAME) ?: ""

        // Переводим techniqueName в читаемое название
        val techniqueDisplayName = when (techniqueName) {
            "BlockReadingTechnique" -> "Чтение \"блоками\""
            "DiagonalReadingTechnique" -> "Чтение по диагонали"
            "KeywordSearchTechnique" -> "Поиск ключевых слов"
            "PointerMethodTechnique" -> "Метод \"указки\""
            "SentenceReverseTechnique" -> "Предложения наоборот"
            "WordReverseTechnique" -> "Слова наоборот"
            else -> techniqueName
        }

        // Устанавливаем заголовок с названием техники
        binding.tvTechniqueTitle.text = techniqueDisplayName

        // Обработчики кнопок скорости
        binding.btnSlowSpeed.setOnClickListener {
            navigateToReadingTest(techniqueName, 200L)
        }
        binding.btnMediumSpeed.setOnClickListener {
            navigateToReadingTest(techniqueName, 400L)
        }
        binding.btnFastSpeed.setOnClickListener {
            navigateToReadingTest(techniqueName, 600L)
        }
    }

    private fun navigateToReadingTest(techniqueName: String, durationPerWord: Long) {
        val fragment = ReadingTestFragment.newInstance(techniqueName, durationPerWord)
        parentFragmentManager.beginTransaction()
            .replace(R.id.fragment_container, fragment)
            .addToBackStack(null)
            .commit()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}package com.example.scorochenie.ui

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.example.scorochenie.domain.Technique

class TechniqueAdapter(
    private val techniques: List<Technique>,
    private val onItemClick: (Technique) -> Unit // Callback для обработки кликов
) : RecyclerView.Adapter<TechniqueAdapter.TechniqueViewHolder>() {

class TechniqueViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    val techniqueName: TextView = itemView.findViewById(android.R.id.text1)
}

override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TechniqueViewHolder {
    val view = LayoutInflater.from(parent.context)
            .inflate(android.R.layout.simple_list_item_1, parent, false)
    return TechniqueViewHolder(view)
}

override fun onBindViewHolder(holder: TechniqueViewHolder, position: Int) {
    val technique = techniques[position]
    holder.techniqueName.text = technique.name
    holder.itemView.setOnClickListener {
        onItemClick(technique)
    }
}

override fun getItemCount(): Int = techniques.size
}package com.example.scorochenie.ui

import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.FrameLayout
import android.widget.ScrollView
import android.widget.TextView
import androidx.fragment.app.Fragment
import com.example.scorochenie.domain.BlockReadingTechnique
import com.example.scorochenie.domain.DiagonalReadingTechnique
import com.example.scorochenie.domain.KeywordSearchTechnique
import com.example.scorochenie.domain.PointerMethodTechnique
import com.example.scorochenie.R
import com.example.scorochenie.domain.ReadingTechnique
import com.example.scorochenie.domain.SentenceReverseTechnique
import com.example.scorochenie.domain.TextResources
import com.example.scorochenie.domain.WordReverseTechnique
import kotlin.random.Random

class TechniqueDetailFragment : Fragment() {

    companion object {
        private const val ARG_TECHNIQUE_NAME = "technique_name"
        fun newInstance(techniqueName: String): TechniqueDetailFragment {
            val fragment = TechniqueDetailFragment()
            val args = Bundle()
            args.putString(ARG_TECHNIQUE_NAME, techniqueName)
            fragment.arguments = args
            return fragment
        }
    }

    private lateinit var technique: ReadingTechnique
    private lateinit var guideView: View
    private var animationTextView: TextView? = null
    private var scrollView: ScrollView? = null

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_technique_detail, container, false)
        val techniqueName = arguments?.getString(ARG_TECHNIQUE_NAME)

        technique = when (techniqueName) {
            "Чтение по диагонали" -> DiagonalReadingTechnique()
            "Поиск ключевых слов" -> KeywordSearchTechnique()
            "Чтение \"блоками\"" -> BlockReadingTechnique()
            "Предложения наоборот" -> SentenceReverseTechnique()
            "Слова наоборот" -> WordReverseTechnique()
            "Метод \"указки\"" -> PointerMethodTechnique()
            else -> object : ReadingTechnique(techniqueName ?: "Неизвестная техника") {
                override fun startAnimation(
                    textView: TextView,
                    guideView: View,
                    durationPerWord: Long,
                    selectedTextIndex: Int,
                    onAnimationEnd: () -> Unit
                ) {
                    textView.text = "Анимация для этой техники недоступна"
                    guideView.visibility = View.INVISIBLE
                    onAnimationEnd()
                }
            }
        }

        val titleTextView = view.findViewById<TextView>(R.id.technique_title)
        val descriptionTextView = view.findViewById<TextView>(R.id.technique_description)
        val scrollContainer = view.findViewById<FrameLayout>(R.id.scroll_container)
        val diagonalContainer = view.findViewById<FrameLayout>(R.id.diagonal_container)
        val startButton = view.findViewById<Button>(R.id.start_button)
        val backButton = view.findViewById<Button>(R.id.back_button)

        titleTextView.text = technique.name
        descriptionTextView.text = technique.description

        guideView = View(requireContext()).apply {
            visibility = View.INVISIBLE
            layoutParams = FrameLayout.LayoutParams(20, 2).apply {
                setMargins(0, 0, 0, 0)
            }
            setBackgroundColor(android.graphics.Color.BLACK)
            Log.d("TechniqueDetail", "guideView initialized with visibility=$visibility")
        }

        // Выбираем нужный контейнер и TextView
        if (technique is DiagonalReadingTechnique) {
            diagonalContainer.visibility = View.VISIBLE
            scrollContainer.visibility = View.GONE
            animationTextView = view.findViewById(R.id.animation_text_diagonal)
        } else {
            scrollContainer.visibility = View.VISIBLE
            diagonalContainer.visibility = View.GONE
            animationTextView = view.findViewById(R.id.animation_text_scroll)
            scrollView = view.findViewById(R.id.scrollView)
        }

        if (technique is DiagonalReadingTechnique || technique is KeywordSearchTechnique || technique is BlockReadingTechnique ||
            technique is PointerMethodTechnique || technique is SentenceReverseTechnique || technique is WordReverseTechnique
        ) {
            animationTextView?.visibility = View.GONE
            startButton.visibility = View.VISIBLE
            startButton.setOnClickListener {
                descriptionTextView.visibility = View.GONE
                startButton.visibility = View.GONE
                animationTextView?.visibility = View.VISIBLE
                backButton.visibility = View.VISIBLE

                // Управление видимостью DiagonalLineView
                val diagonalLineView = diagonalContainer.findViewById<DiagonalLineView>(R.id.diagonal_line_view)
                if (technique is DiagonalReadingTechnique && diagonalLineView != null) {
                    diagonalLineView.visibility = View.VISIBLE
                    Log.d("TechniqueDetail", "DiagonalLineView set to VISIBLE")
                } else {
                    diagonalLineView?.visibility = View.GONE
                    Log.d("TechniqueDetail", "DiagonalLineView set to GONE")
                }

                // Добавляем guideView в активный контейнер
                val activeContainer = if (technique is DiagonalReadingTechnique) diagonalContainer else scrollContainer
                if (guideView.parent == null) {
                    activeContainer.addView(guideView)
                    Log.d("TechniqueDetail", "guideView added to activeContainer, visibility=${guideView.visibility}")
                }

                // Устанавливаем значение durationPerWord по умолчанию (400 WPM)
                val defaultDurationPerWord = 400L
                // Выбираем размер списка текстов в зависимости от техники
                val textListSize = when (technique) {
                    is DiagonalReadingTechnique -> TextResources.diagonalTexts.size
                    is KeywordSearchTechnique -> TextResources.keywordTexts.size
                    else -> TextResources.otherTexts[technique.name]?.size ?: 1
                }
                val selectedTextIndex = Random.nextInt(textListSize)

                Log.d("TechniqueDetail", "Starting animation with default durationPerWord=$defaultDurationPerWord WPM and textIndex=$selectedTextIndex, textListSize=$textListSize")

                animationTextView?.let { textView ->
                    technique.startAnimation(textView, guideView, defaultDurationPerWord, selectedTextIndex) {
                        val parent = guideView.parent as? ViewGroup
                        parent?.removeView(guideView)
                        animationTextView?.visibility = View.VISIBLE
                        backButton.visibility = View.VISIBLE
                        guideView.visibility = View.INVISIBLE
                        Log.d("TechniqueDetail", "Animation ended, guideView removed and set to INVISIBLE")
                    }
                }
            }
        } else {
            animationTextView?.text = "Анимация для этой техники в разработке."
            animationTextView?.visibility = View.VISIBLE
            startButton.visibility = View.GONE
            val diagonalLineView = diagonalContainer.findViewById<DiagonalLineView>(R.id.diagonal_line_view)
            diagonalLineView?.visibility = View.GONE
            guideView.visibility = View.INVISIBLE
            Log.d("TechniqueDetail", "No animation, guideView set to INVISIBLE")
        }

        backButton.setOnClickListener {
            parentFragmentManager.popBackStack()
        }

        return view
    }

    override fun onDestroyView() {
        super.onDestroyView()
        // Очистка guideView
        val parent = guideView.parent as? ViewGroup
        parent?.removeView(guideView)
        guideView.visibility = View.INVISIBLE
        Log.d("TechniqueDetail", "onDestroyView: guideView removed and set to INVISIBLE")
        animationTextView = null
        scrollView = null
    }
}package com.example.scorochenie.ui

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView

class TechniqueSelectionAdapter(
    private val techniques: List<TechniqueItem>,
    private val onItemClick: (String) -> Unit
) : RecyclerView.Adapter<TechniqueSelectionAdapter.TechniqueViewHolder>() {

    class TechniqueViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val techniqueName: TextView = itemView.findViewById(android.R.id.text1)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TechniqueViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(android.R.layout.simple_list_item_1, parent, false)
        return TechniqueViewHolder(view)
    }

    override fun onBindViewHolder(holder: TechniqueViewHolder, position: Int) {
        val technique = techniques[position]
        holder.techniqueName.text = technique.displayName
        holder.itemView.setOnClickListener {
            onItemClick(technique.name)
        }
    }

    override fun getItemCount(): Int = techniques.size
}package com.example.scorochenie.ui

import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RadioButton
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.example.scorochenie.domain.TextResources
import com.example.scorochenie.databinding.FragmentTestBinding
import org.json.JSONObject

class TestFragment : Fragment() {

    companion object {
        private const val ARG_TEXT_INDEX = "textIndex"
        private const val ARG_TECHNIQUE_NAME = "techniqueName"
        private const val ARG_DURATION_PER_WORD = "durationPerWord"

        fun newInstance(textIndex: Int, techniqueName: String, durationPerWord: Long): TestFragment {
            return TestFragment().apply {
                arguments = Bundle().apply {
                    putInt(ARG_TEXT_INDEX, textIndex)
                    putString(ARG_TECHNIQUE_NAME, techniqueName)
                    putLong(ARG_DURATION_PER_WORD, durationPerWord)
                }
            }
        }
    }

    private var _binding: FragmentTestBinding? = null
    private val binding get() = _binding!!
    private var score = 0
    private var currentTextIndex = 0
    private var techniqueName: String = ""
    private var durationPerWord: Long = 400L

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTestBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        currentTextIndex = arguments?.getInt(ARG_TEXT_INDEX, 0) ?: 0
        techniqueName = arguments?.getString(ARG_TECHNIQUE_NAME) ?: ""
        durationPerWord = arguments?.getLong(ARG_DURATION_PER_WORD) ?: 400L

        Log.d("TestFragment", "onViewCreated: techniqueName='$techniqueName', currentTextIndex=$currentTextIndex, durationPerWord=$durationPerWord")

        displayQuestion(0)

        binding.btnSubmit.setOnClickListener {
            checkAnswer()
        }
    }

    private fun displayQuestion(index: Int) {
        val normalizedTechniqueName = when (techniqueName) {
            "DiagonalReadingTechnique" -> "Чтение по диагонали"
            "KeywordSearchTechnique" -> "Поиск ключевых слов"
            "BlockReadingTechnique" -> "Чтение блоками"
            "SentenceReverseTechnique" -> "Предложения наоборот"
            "WordReverseTechnique" -> "Слова наоборот"
            "PointerMethodTechnique" -> "Метод указки"
            else -> techniqueName
        }

        Log.d("TestFragment", "displayQuestion: index=$index, normalizedTechniqueName='$normalizedTechniqueName'")

        val questions = when (normalizedTechniqueName) {
            "Чтение по диагонали" -> TextResources.diagonalTexts.getOrNull(currentTextIndex)?.questionsAndAnswers
            "Поиск ключевых слов" -> TextResources.keywordTexts.getOrNull(currentTextIndex)?.questionsAndAnswers
            else -> {
                Log.d("TestFragment", "Attempting to access otherTexts with key: '$normalizedTechniqueName'")
                Log.d("TestFragment", "Available keys in otherTexts: ${TextResources.otherTexts.keys}")
                TextResources.otherTexts[normalizedTechniqueName]?.getOrNull(currentTextIndex)?.questionsAndAnswers
            }
        }

        Log.d("TestFragment", "Questions: size=${questions?.size ?: 0}, questions=$questions")

        if (questions.isNullOrEmpty()) {
            Log.e("TestFragment", "No questions found for technique='$normalizedTechniqueName', textIndex=$currentTextIndex")
            binding.tvQuestionHeader.visibility = View.GONE
            binding.questionText.text = "Ошибка: вопросы для этой техники недоступны."
            binding.radioGroup.visibility = View.GONE
            binding.btnSubmit.visibility = View.GONE
            return
        }

        if (index < questions.size) {
            val questionPair = questions[index]
            binding.questionText.text = questionPair.first
            binding.questionText.tag = Pair(index, questionPair.second[0])

            binding.tvQuestionHeader.text = "Вопрос ${index + 1}"

            binding.radioGroup.removeAllViews()
            val options = questionPair.second.shuffled()
            options.forEach { option ->
                val radioButton = RadioButton(context).apply {
                    text = option
                    id = View.generateViewId()
                    textSize = 16f
                    setTextColor(ContextCompat.getColor(context, android.R.color.white))
                }
                binding.radioGroup.addView(radioButton)
            }
            Log.d("TestFragment", "Displayed question $index: '${questionPair.first}', options=$options")
        } else {
            showResult()
        }
    }

    private fun checkAnswer() {
        val selectedRadioButtonId = binding.radioGroup.checkedRadioButtonId
        if (selectedRadioButtonId == -1) {
            Toast.makeText(context, "Выберите ответ", Toast.LENGTH_SHORT).show()
            return
        }

        val selectedRadioButton = binding.radioGroup.findViewById<RadioButton>(selectedRadioButtonId)
        val userAnswer = selectedRadioButton.text.toString().lowercase()
        val correctAnswer = (binding.questionText.tag as? Pair<*, *>)?.second as? String ?: ""
        if (userAnswer == correctAnswer.lowercase()) {
            score++
        }

        Log.d("TestFragment", "Checked answer: userAnswer='$userAnswer', correctAnswer='$correctAnswer', score=$score")

        binding.radioGroup.clearCheck()
        displayQuestion(((binding.questionText.tag as? Pair<*, *>)?.first as? Int ?: 0) + 1)
    }

    private fun showResult() {
        val normalizedTechniqueName = when (techniqueName) {
            "DiagonalReadingTechnique" -> "Чтение по диагонали"
            "KeywordSearchTechnique" -> "Поиск ключевых слов"
            "BlockReadingTechnique" -> "Чтение блоками"
            "SentenceReverseTechnique" -> "Предложения наоборот"
            "WordReverseTechnique" -> "Слова наоборот"
            "PointerMethodTechnique" -> "Метод указки"
            else -> techniqueName
        }

        val totalQuestions = when (normalizedTechniqueName) {
            "Чтение по диагонали" -> TextResources.diagonalTexts.getOrNull(currentTextIndex)?.questionsAndAnswers?.size
            "Поиск ключевых слов" -> TextResources.keywordTexts.getOrNull(currentTextIndex)?.questionsAndAnswers?.size
            else -> TextResources.otherTexts[normalizedTechniqueName]?.getOrNull(currentTextIndex)?.questionsAndAnswers?.size
        } ?: 0

        Log.d("TestFragment", "showResult: score=$score, totalQuestions=$totalQuestions, techniqueName='$normalizedTechniqueName'")

        binding.tvQuestionHeader.visibility = View.GONE
        binding.questionText.text = "Тест завершён! Ваш результат: $score из $totalQuestions"
        binding.radioGroup.visibility = View.GONE
        binding.btnSubmit.visibility = View.GONE

        saveTestResult(normalizedTechniqueName, totalQuestions)
    }

    private fun saveTestResult(normalizedTechniqueName: String, totalQuestions: Int) {
        val sharedPreferences = requireContext().getSharedPreferences("TestResults", Context.MODE_PRIVATE)
        val editor = sharedPreferences.edit()
        val key = "result_$normalizedTechniqueName" // Единый ключ для техники

        // Получаем существующий результат, если он есть
        val existingResultJson = sharedPreferences.getString(key, null)
        var shouldSave = true

        if (existingResultJson != null) {
            try {
                val existingResult = JSONObject(existingResultJson)
                val existingScore = existingResult.getInt("score")
                val existingDuration = existingResult.getLong("durationPerWord")

                // Сохраняем, если новый score выше, или если score равен, но durationPerWord меньше
                if (score < existingScore || (score == existingScore && durationPerWord >= existingDuration)) {
                    shouldSave = false
                }
            } catch (e: Exception) {
                Log.e("TestFragment", "Failed to parse existing result JSON: $existingResultJson", e)
            }
        }

        if (shouldSave) {
            val timestamp = System.currentTimeMillis()
            val resultJson = """
                {
                    "techniqueName": "$normalizedTechniqueName",
                    "durationPerWord": $durationPerWord,
                    "score": $score,
                    "totalQuestions": $totalQuestions,
                    "timestamp": $timestamp
                }
            """
            editor.putString(key, resultJson)
            editor.apply()
            Log.d("TestFragment", "Saved result: key=$key, resultJson=$resultJson")
        } else {
            Log.d("TestFragment", "Skipped saving: new result (score=$score, duration=$durationPerWord) not better than existing")
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}package com.example.scorochenie

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import com.example.scorochenie.ui.ExercisesFragment
import com.example.scorochenie.ui.MaterialsFragment
import com.example.scorochenie.ui.RatingFragment
import com.google.android.material.bottomnavigation.BottomNavigationView

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Настройка BottomNavigationView
        val bottomNavigation = findViewById<BottomNavigationView>(R.id.bottom_navigation)
        bottomNavigation.setOnItemSelectedListener { item ->
            when (item.itemId) {
                R.id.nav_rating -> {
                    loadFragment(RatingFragment())
                    true
                }
                R.id.nav_exercises -> {
                    loadFragment(ExercisesFragment())
                    true
                }
                R.id.nav_materials -> {
                    loadFragment(MaterialsFragment())
                    true
                }
                else -> false
            }
        }

        // Загружаем первый фрагмент при запуске
        if (savedInstanceState == null) {
            loadFragment(RatingFragment())
        }
    }

    private fun loadFragment(fragment: Fragment) {
        supportFragmentManager.beginTransaction()
            .replace(R.id.fragment_container, fragment)
            .commit()
    }
}
